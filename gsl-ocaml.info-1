This is gsl-ocaml.info, produced by makeinfo version 4.13 from
gsl-ocaml.texi.

INFO-DIR-SECTION Objective Caml
START-INFO-DIR-ENTRY
* gsl-ocaml 0.6.0: (gsl-ocaml).
END-INFO-DIR-ENTRY
   This file was generated by Ocamldoc using the Texinfo generator.


File: gsl-ocaml.info,  Node: Top,  Up: (dir)

gsl-ocaml 0.6.0
***************

Documentation for gsl-ocaml 0.6.0

* Menu:

* Gsl_error::                      Module
* Gsl_ieee::                       Module
* Gsl_math::                       Module
* Gsl_complex::                    Module
* Gsl_vector::                     Module
* Gsl_vector_flat::                Module
* Gsl_vector_complex::             Module
* Gsl_vector_complex_flat::        Module
* Gsl_matrix::                     Module
* Gsl_matrix_flat::                Module
* Gsl_matrix_complex::             Module
* Gsl_matrix_complex_flat::        Module
* Gsl_vectmat::                    Module
* Gsl_blas::                       Module
* Gsl_blas_flat::                  Module
* Gsl_blas_gen::                   Module
* Gsl_fun::                        Module
* Gsl_permut::                     Module
* Gsl_sort::                       Module
* Gsl_linalg::                     Module
* Gsl_eigen::                      Module
* Gsl_poly::                       Module
* Gsl_interp::                     Module
* Gsl_rng::                        Module
* Gsl_qrng::                       Module
* Gsl_randist::                    Module
* Gsl_integration::                Module
* Gsl_fit::                        Module
* Gsl_multifit::                   Module
* Gsl_multifit_nlin::              Module
* Gsl_root::                       Module
* Gsl_multiroot::                  Module
* Gsl_min::                        Module
* Gsl_multimin::                   Module
* Gsl_diff::                       Module
* Gsl_cheb::                       Module
* Gsl_sum::                        Module
* Gsl_fft::                        Module
* Gsl_monte::                      Module
* Gsl_siman::                      Module
* Gsl_odeiv::                      Module
* Gsl_histo::                      Module
* Gsl_stats::                      Module
* Gsl_wavelet::                    Module
* Gsl_bspline::                    Module
* Gsl_const::                      Module
* Gsl_sf::                         Module
* Gsl_cdf::                        Module

Indices :
* Types index::
* Exceptions index::
* Values index::
* Modules index::


File: gsl-ocaml.info,  Node: Gsl_error,  Next: Gsl_ieee,  Prev: Top,  Up: Top

1 Module `Gsl_error'
********************

1.1 Description
===============

Error reporting

1.2 Interface
=============


 - val version :
     string

   version of GSL library


 - type errno =
  | CONTINUE
     (* iteration has not converged *)
  | FAILURE
  | EDOM
     (* input domain error, e.g sqrt(-1) *)
  | ERANGE
     (* output range error, e.g. exp(1e100) *)
  | EFAULT
     (* invalid pointer *)
  | EINVAL
     (* invalid argument supplied by user *)
  | EFAILED
     (* generic failure *)
  | EFACTOR
     (* factorization failed *)
  | ESANITY
     (* sanity check failed - shouldn't happen *)
  | ENOMEM
     (* malloc failed *)
  | EBADFUNC
     (* problem with user-supplied function *)
  | ERUNAWAY
     (* iterative process is out of control *)
  | EMAXITER
     (* exceeded max number of iterations *)
  | EZERODIV
     (* tried to divide by zero *)
  | EBADTOL
     (* user specified an invalid tolerance *)
  | ETOL
     (* failed to reach the specified tolerance *)
  | EUNDRFLW
     (* underflow *)
  | EOVRFLW
     (* overflow *)
  | ELOSS
     (* loss of accuracy *)
  | EROUND
     (* failed because of roundoff error *)
  | EBADLEN
     (* matrix, vector lengths are not conformant *)
  | ENOTSQR
     (* matrix not square *)
  | ESING
     (* apparent singularity detected *)
  | EDIVERGE
     (* integral or series is divergent *)
  | EUNSUP
     (* requested feature is not supported by the hardware *)
  | EUNIMPL
     (* requested feature not (yet) implemented *)
  | ECACHE
     (* cache limit exceeded *)
  | ETABLE
     (* table limit exceeded *)
  | ENOPROG
     (* iteration is not making progress towards solution *)
  | ENOPROGJ
     (* jacobian evaluations are not improving the solution *)
  | ETOLF
     (* cannot reach the specified tolerance in F *)
  | ETOLX
     (* cannot reach the specified tolerance in X *)
  | ETOLG
     (* cannot reach the specified tolerance in gradient *)
  | EOF
     (* end of file *)
   

 - exception Gsl_exn of (Gsl_error.errno * string)
   

 - val init :
     unit -> unit
   

 - val uninit :
     unit -> unit
   

 - val strerror :
     errno -> string
   

 - val string_of_errno :
     errno -> string
   

 - val pprint_exn :
     exn -> string
   

 - val handle_exn :
     ('a -> 'b) -> 'a -> 'b
   

File: gsl-ocaml.info,  Node: Gsl_ieee,  Next: Gsl_math,  Prev: Gsl_error,  Up: Top

2 Module `Gsl_ieee'
*******************

2.1 Description
===============

IEEE floating-point arithmetic

2.2 Interface
=============

2.2.1 Representation of floating point numbers
----------------------------------------------


 - type ieee_type =
  | NAN
  | INF
  | NORMAL
  | DENORMAL
  | ZERO


 - type float_rep = {
  sign : int ;
  mantissa : string ;
  exponent : int ;
  ieee_type : Gsl_ieee.ieee_type ;
 }
   

 - val rep_of_float :
     float -> float_rep
   

 - val print :
     float -> string
   
2.2.2 IEEE environment
----------------------


 - type precision =
  | SINGLE
  | DOUBLE
  | EXTENDED


 - type rounding =
  | TO_NEAREST
  | DOWN
  | UP
  | TO_ZERO
   

 - type exceptions =
  | MASK_INVALID
  | MASK_DENORMALIZED
  | MASK_DIVISION_BY_ZERO
  | MASK_OVERFLOW
  | MASK_UNDERFLOW
  | MASK_ALL
  | TRAP_INEXACT
   

 - val set_mode :
     ?precision:precision ->
       ?rounding:rounding -> exceptions list -> unit
   

 - val env_setup :
     unit -> unit
   
2.2.3 FPU status word
---------------------


 - type excepts =
  | FE_INEXACT
  | FE_DIVBYZERO
  | FE_UNDERFLOW
  | FE_OVERFLOW
  | FE_INVALID
  | FE_ALL_EXCEPT


 - val clear_except :
     excepts list -> unit
   

 - val test_except :
     excepts list -> excepts list
   

File: gsl-ocaml.info,  Node: Gsl_math,  Next: Gsl_complex,  Prev: Gsl_ieee,  Up: Top

3 Module `Gsl_math'
*******************

3.1 Description
===============

Mathematical constants and some simple functions

3.2 Interface
=============

3.2.1 Constants
---------------


 - val e :
     float

   e


 - val log2e :
     float
   
   log_2 (e)


 - val log10e :
     float
   
   log_10 (e)


 - val sqrt2 :
     float
   
   sqrt(2)


 - val sqrt1_2 :
     float
   
   sqrt(1/2)


 - val sqrt3 :
     float
   
   sqrt(3)


 - val pi :
     float
   
   pi


 - val pi_2 :
     float
   
   pi/2


 - val pi_4 :
     float
   
   pi/4


 - val sqrtpi :
     float
   
   sqrt(pi)


 - val i_2_sqrtpi :
     float
   
   2/sqrt(pi)


 - val i_1_pi :
     float
   
   1/pi


 - val i_2_pi :
     float
   
   2/pi


 - val ln10 :
     float
   
   ln(10)


 - val ln2 :
     float
   
   ln(2)


 - val lnpi :
     float
   
   ln(pi)


 - val euler :
     float
   
   Euler constant

3.2.2 Simple Functions
----------------------


 - val pow_int :
     float -> int -> float


 - val log1p :
     float -> float
   

 - val expm1 :
     float -> float
   

 - val hypot :
     float -> float -> float
   

 - val acosh :
     float -> float
   

 - val asinh :
     float -> float
   

 - val atanh :
     float -> float
   

 - val fcmp :
     float -> float -> epsilon:float -> int
   

File: gsl-ocaml.info,  Node: Gsl_complex,  Next: Gsl_vector,  Prev: Gsl_math,  Up: Top

4 Module `Gsl_complex'
**********************

4.1 Description
===============

Complex arithmetic and simple functions

4.2 Interface
=============


 - type complex = Complex.t = {
  re : float ;
  im : float ;
 }


 - val complex :
     re:float -> im:float -> complex
   

 - type complex_array = float array
   

 - val set :
     complex_array -> int -> complex -> unit
   

 - val get :
     complex_array -> int -> complex
   

 - val unpack :
     complex_array -> complex array
   

 - val pack :
     complex array -> complex_array
   

 - val mult :
     complex_array -> complex_array -> unit
   

 - val rect :
     float -> float -> complex
   

 - val polar :
     float -> float -> complex
   
4.2.0.1 Properties of complex numbers
.....................................


 - val arg :
     complex -> float


 - val abs :
     complex -> float
   

 - val abs2 :
     complex -> float
   

 - val logabs :
     complex -> float
   
4.2.0.2 Complex arithmetic operators
....................................


 - val add :
     complex -> complex -> complex


 - val sub :
     complex -> complex -> complex
   

 - val mul :
     complex -> complex -> complex
   

 - val div :
     complex -> complex -> complex
   

 - val add_real :
     complex -> float -> complex
   

 - val sub_real :
     complex -> float -> complex
   

 - val mul_real :
     complex -> float -> complex
   

 - val div_real :
     complex -> float -> complex
   

 - val add_imag :
     complex -> float -> complex
   

 - val sub_imag :
     complex -> float -> complex
   

 - val mul_imag :
     complex -> float -> complex
   

 - val div_imag :
     complex -> float -> complex
   

 - val conjugate :
     complex -> complex
   

 - val inverse :
     complex -> complex
   

 - val negative :
     complex -> complex
   
4.2.0.3 Elementary complex functions
....................................


 - val sqrt :
     complex -> complex


 - val sqrt_real :
     float -> complex
   

 - val pow :
     complex -> complex -> complex
   

 - val pow_real :
     complex -> float -> complex
   

 - val exp :
     complex -> complex
   

 - val log :
     complex -> complex
   

 - val log10 :
     complex -> complex
   

 - val log_b :
     complex -> complex -> complex
   
4.2.0.4 Complex trigonometric functions
.......................................


 - val sin :
     complex -> complex


 - val cos :
     complex -> complex
   

 - val tan :
     complex -> complex
   

 - val sec :
     complex -> complex
   

 - val csc :
     complex -> complex
   

 - val cot :
     complex -> complex
   
4.2.0.5 Inverse complex trigonometric functions
...............................................


 - val arcsin :
     complex -> complex


 - val arcsin_real :
     float -> complex
   

 - val arccos :
     complex -> complex
   

 - val arccos_real :
     float -> complex
   

 - val arctan :
     complex -> complex
   

 - val arcsec :
     complex -> complex
   

 - val arcsec_real :
     float -> complex
   

 - val arccsc :
     complex -> complex
   

 - val arccsc_real :
     float -> complex
   

 - val arccot :
     complex -> complex
   
4.2.0.6 Complex hyperbolic functions
....................................


 - val sinh :
     complex -> complex


 - val cosh :
     complex -> complex
   

 - val tanh :
     complex -> complex
   

 - val sech :
     complex -> complex
   

 - val csch :
     complex -> complex
   

 - val coth :
     complex -> complex
   
4.2.0.7 Inverse complex hyperbolic functions
............................................


 - val arcsinh :
     complex -> complex


 - val arccosh :
     complex -> complex
   

 - val arccosh_real :
     float -> complex
   

 - val arctanh :
     complex -> complex
   

 - val arctanh_real :
     float -> complex
   

 - val arcsech :
     complex -> complex
   

 - val arccsch :
     complex -> complex
   

 - val arccoth :
     complex -> complex
   

File: gsl-ocaml.info,  Node: Gsl_vector,  Next: Gsl_vector_flat,  Prev: Gsl_complex,  Up: Top

5 Module `Gsl_vector'
*********************

5.1 Description
===============

Vector of floats implemented with `Bigarray'

Subparts
========

* Menu:

* Single: Gsl_vector/Single.       Module

5.2 Interface
=============

5.2.1 Double precision
----------------------


 - type double_vector_bigarr = (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Array1.t


 - type vector = double_vector_bigarr
   
5.2.1.1 Operations
..................


 - val create :
     ?init:float -> int -> vector


 - val of_array :
     float array -> vector
   

 - val to_array :
     vector -> float array
   

 - val length :
     vector -> int
   

 - val get :
     vector -> int -> float
   

 - val set :
     vector -> int -> float -> unit
   

 - val set_all :
     vector -> float -> unit
   

 - val set_zero :
     vector -> unit
   

 - val set_basis :
     vector -> int -> unit
   

 - val memcpy :
     src:vector -> dst:vector -> unit
   

 - val copy :
     vector -> vector
   

 - val swap_element :
     vector -> int -> int -> unit
   

 - val reverse :
     vector -> unit
   

 - val add :
     vector -> vector -> unit
   

 - val sub :
     vector -> vector -> unit
   

 - val mul :
     vector -> vector -> unit
   

 - val div :
     vector -> vector -> unit
   

 - val scale :
     vector -> float -> unit
   

 - val add_constant :
     vector -> float -> unit
   

 - val is_null :
     vector -> bool
   

 - val max :
     vector -> float
   

 - val min :
     vector -> float
   

 - val minmax :
     vector -> float * float
   

 - val max_index :
     vector -> int
   

 - val min_index :
     vector -> int
   

 - val minmax_index :
     vector -> int * int
   
5.2.1.2 No-copy operations
..........................


 - val subvector :
     vector -> off:int -> len:int -> vector

5.2.2 Single precision
----------------------


 - module Single
*Note Module Single: Gsl_vector/Single.


File: gsl-ocaml.info,  Node: Gsl_vector/Single,  Up: Gsl_vector

5.3 Module `Gsl_vector.Single'
==============================

5.3.1 Interface
---------------


 - type float_vector_bigarr = (float, Bigarray.float32_elt, Bigarray.c_layout) Bigarray.Array1.t


 - type vector = float_vector_bigarr
   

 - val create :
     ?init:float -> int -> vector
   

 - val of_array :
     float array -> vector
   

 - val to_array :
     vector -> float array
   

 - val length :
     vector -> int
   

 - val get :
     vector -> int -> float
   

 - val set :
     vector -> int -> float -> unit
   

 - val set_all :
     vector -> float -> unit
   

 - val set_zero :
     vector -> unit
   

 - val set_basis :
     vector -> int -> unit
   

 - val memcpy :
     src:vector -> dst:vector -> unit
   

 - val copy :
     vector -> vector
   

 - val swap_element :
     vector -> int -> int -> unit
   

 - val reverse :
     vector -> unit
   

 - val add :
     vector -> vector -> unit
   

 - val sub :
     vector -> vector -> unit
   

 - val mul :
     vector -> vector -> unit
   

 - val div :
     vector -> vector -> unit
   

 - val scale :
     vector -> float -> unit
   

 - val add_constant :
     vector -> float -> unit
   

 - val is_null :
     vector -> bool
   

 - val max :
     vector -> float
   

 - val min :
     vector -> float
   

 - val minmax :
     vector -> float * float
   

 - val max_index :
     vector -> int
   

 - val min_index :
     vector -> int
   

 - val minmax_index :
     vector -> int * int
   
5.3.1.1 No-copy operations
..........................


 - val subvector :
     vector -> off:int -> len:int -> vector


File: gsl-ocaml.info,  Node: Gsl_vector_flat,  Next: Gsl_vector_complex,  Prev: Gsl_vector,  Up: Top

6 Module `Gsl_vector_flat'
**************************

6.1 Description
===============

Vector of floats implemented with a `float array'

6.2 Interface
=============


 - type double_vector_flat = private {
  data : float array ;
  off : int ;
  len : int ;
  stride : int ;
 }


 - type vector = double_vector_flat
   

 - val check :
     vector -> vector
   
*Raises* `Failure' if `off', `len' or `stride' designate an invalid
 subvector of `data'

6.2.1 Operations
----------------


 - val create :
     ?init:float -> int -> vector


 - val of_array :
     float array -> vector
   

 - val to_array :
     vector -> float array
   

 - val length :
     vector -> int
   

 - val get :
     vector -> int -> float
   

 - val set :
     vector -> int -> float -> unit
   

 - val set_all :
     vector -> float -> unit
   

 - val set_zero :
     vector -> unit
   

 - val set_basis :
     vector -> int -> unit
   

 - val memcpy :
     src:vector -> dst:vector -> unit
   

 - val copy :
     vector -> vector
   

 - val swap_element :
     vector -> int -> int -> unit
   

 - val reverse :
     vector -> unit
   

 - val add :
     vector -> vector -> unit
   

 - val sub :
     vector -> vector -> unit
   

 - val mul :
     vector -> vector -> unit
   

 - val div :
     vector -> vector -> unit
   

 - val scale :
     vector -> float -> unit
   

 - val add_constant :
     vector -> float -> unit
   

 - val is_null :
     vector -> bool
   

 - val max :
     vector -> float
   

 - val min :
     vector -> float
   

 - val minmax :
     vector -> float * float
   

 - val max_index :
     vector -> int
   

 - val min_index :
     vector -> int
   

 - val minmax_index :
     vector -> int * int
   
6.2.2 No-copy operations
------------------------


 - val subvector :
     ?stride:int ->
       vector -> off:int -> len:int -> vector


 - val view_array :
     ?stride:int -> ?off:int -> ?len:int -> float array -> vector
   

File: gsl-ocaml.info,  Node: Gsl_vector_complex,  Next: Gsl_vector_complex_flat,  Prev: Gsl_vector_flat,  Up: Top

7 Module `Gsl_vector_complex'
*****************************

7.1 Description
===============

Vector of complex numbers implemented with a `Bigarray'

Subparts
========

* Menu:

* Single: Gsl_vector_complex/Single. Module

7.2 Interface
=============


 - type complex_double_vector_bigarr = (Complex.t, Bigarray.complex64_elt, Bigarray.c_layout) Bigarray.Array1.t


 - type vector = complex_double_vector_bigarr
   

 - val create :
     ?init:Gsl_complex.complex -> int -> vector
   

 - val of_array :
     Gsl_complex.complex array -> vector
   

 - val to_array :
     vector -> Gsl_complex.complex array
   

 - val of_complex_array :
     Gsl_complex.complex_array -> vector
   

 - val to_complex_array :
     vector -> Gsl_complex.complex_array
   

 - val length :
     vector -> int
   

 - val get :
     vector -> int -> Gsl_complex.complex
   

 - val set :
     vector -> int -> Gsl_complex.complex -> unit
   

 - val set_all :
     vector -> Gsl_complex.complex -> unit
   

 - val set_zero :
     vector -> unit
   

 - val set_basis :
     vector -> int -> unit
   

 - val memcpy :
     src:vector -> dst:vector -> unit
   

 - val copy :
     vector -> vector
   

 - val swap_element :
     vector -> int -> int -> unit
   

 - val reverse :
     vector -> unit
   

 - val subvector :
     vector -> off:int -> len:int -> vector
   

 - module Single
   *Note Module Single: Gsl_vector_complex/Single.


File: gsl-ocaml.info,  Node: Gsl_vector_complex/Single,  Up: Gsl_vector_complex

7.3 Module `Gsl_vector_complex.Single'
======================================

7.3.1 Interface
---------------


 - type complex_float_vector_bigarr = (Complex.t, Bigarray.complex32_elt, Bigarray.c_layout) Bigarray.Array1.t


 - type vector = complex_float_vector_bigarr
   

 - val create :
     ?init:Gsl_complex.complex -> int -> vector
   

 - val of_array :
     Gsl_complex.complex array -> vector
   

 - val to_array :
     vector -> Gsl_complex.complex array
   

 - val of_complex_array :
     Gsl_complex.complex_array -> vector
   

 - val to_complex_array :
     vector -> Gsl_complex.complex_array
   

 - val length :
     vector -> int
   

 - val get :
     vector -> int -> Gsl_complex.complex
   

 - val set :
     vector -> int -> Gsl_complex.complex -> unit
   

 - val set_all :
     vector -> Gsl_complex.complex -> unit
   

 - val set_zero :
     vector -> unit
   

 - val set_basis :
     vector -> int -> unit
   

 - val memcpy :
     src:vector ->
       dst:vector -> unit
   

 - val copy :
     vector -> vector
   

 - val swap_element :
     vector -> int -> int -> unit
   

 - val reverse :
     vector -> unit
   

 - val subvector :
     vector ->
       off:int -> len:int -> vector
   

File: gsl-ocaml.info,  Node: Gsl_vector_complex_flat,  Next: Gsl_matrix,  Prev: Gsl_vector_complex,  Up: Top

8 Module `Gsl_vector_complex_flat'
**********************************

8.1 Description
===============

Vector of complex numbers implemented with a `float array'

8.2 Interface
=============


 - type complex_vector_flat = private {
  data : float array ;
  off : int ;
  len : int ;
  stride : int ;
 }


 - type vector = complex_vector_flat
   
8.2.1 Operations
----------------


 - val create :
     ?init:Gsl_complex.complex -> int -> vector


 - val of_array :
     Gsl_complex.complex array -> vector
   

 - val to_array :
     vector -> Gsl_complex.complex array
   

 - val of_complex_array :
     Gsl_complex.complex_array -> vector
   

 - val to_complex_array :
     vector -> Gsl_complex.complex_array
   

 - val length :
     vector -> int
   

 - val get :
     vector -> int -> Gsl_complex.complex
   

 - val set :
     vector -> int -> Gsl_complex.complex -> unit
   

 - val set_all :
     vector -> Gsl_complex.complex -> unit
   

 - val set_zero :
     vector -> unit
   

 - val set_basis :
     vector -> int -> unit
   

 - val memcpy :
     vector -> vector -> unit
   

 - val copy :
     vector -> vector
   

 - val swap_element :
     vector -> int -> int -> unit
   

 - val reverse :
     vector -> unit
   
8.2.2 No-copy operations
------------------------


 - val subvector :
     ?stride:int ->
       vector ->
       off:int -> len:int -> vector


 - val view_complex_array :
     ?stride:int ->
       ?off:int ->
       ?len:int -> Gsl_complex.complex_array -> vector
   

 - val real :
     vector -> Gsl_vector_flat.vector
   

 - val imag :
     vector -> Gsl_vector_flat.vector
   

File: gsl-ocaml.info,  Node: Gsl_matrix,  Next: Gsl_matrix_flat,  Prev: Gsl_vector_complex_flat,  Up: Top

9 Module `Gsl_matrix'
*********************

9.1 Description
===============

Matrices of floats implemented with `Bigarray'

Subparts
========

* Menu:

* Single: Gsl_matrix/Single.       Module

9.2 Interface
=============


 - type double_mat_bigarr = (float, Bigarray.float64_elt, Bigarray.c_layout) Bigarray.Array2.t


 - type matrix = double_mat_bigarr
   

 - val create :
     ?init:float -> int -> int -> matrix
   

 - val dims :
     matrix -> int * int
   

 - val of_array :
     float array -> int -> int -> matrix
   

 - val of_arrays :
     float array array -> matrix
   

 - val to_array :
     matrix -> float array
   

 - val to_arrays :
     matrix -> float array array
   

 - val get :
     matrix -> int -> int -> float
   

 - val set :
     matrix -> int -> int -> float -> unit
   

 - val set_all :
     matrix -> float -> unit
   

 - val set_zero :
     matrix -> unit
   

 - val set_id :
     matrix -> unit
   

 - val memcpy :
     src:matrix -> dst:matrix -> unit
   

 - val copy :
     matrix -> matrix
   

 - val row :
     matrix -> int -> Gsl_vector.vector
   

 - val add :
     matrix -> matrix -> unit
   

 - val sub :
     matrix -> matrix -> unit
   

 - val mul_elements :
     matrix -> matrix -> unit
   

 - val div_elements :
     matrix -> matrix -> unit
   

 - val scale :
     matrix -> float -> unit
   

 - val add_constant :
     matrix -> float -> unit
   

 - val add_diagonal :
     matrix -> float -> unit
   

 - val is_null :
     matrix -> bool
   

 - val swap_rows :
     matrix -> int -> int -> unit
   

 - val swap_columns :
     matrix -> int -> int -> unit
   

 - val swap_rowcol :
     matrix -> int -> int -> unit
   

 - val transpose :
     matrix -> matrix -> unit
   

 - val transpose_in_place :
     matrix -> unit
   

 - module Single
   *Note Module Single: Gsl_matrix/Single.


File: gsl-ocaml.info,  Node: Gsl_matrix/Single,  Up: Gsl_matrix

9.3 Module `Gsl_matrix.Single'
==============================

9.3.1 Interface
---------------


 - type float_mat_bigarr = (float, Bigarray.float32_elt, Bigarray.c_layout) Bigarray.Array2.t


 - type matrix = float_mat_bigarr
   

 - val create :
     ?init:float -> int -> int -> matrix
   

 - val dims :
     matrix -> int * int
   

 - val of_array :
     float array -> int -> int -> matrix
   

 - val of_arrays :
     float array array -> matrix
   

 - val to_array :
     matrix -> float array
   

 - val to_arrays :
     matrix -> float array array
   

 - val get :
     matrix -> int -> int -> float
   

 - val set :
     matrix -> int -> int -> float -> unit
   

 - val set_all :
     matrix -> float -> unit
   

 - val set_zero :
     matrix -> unit
   

 - val set_id :
     matrix -> unit
   

 - val memcpy :
     src:matrix -> dst:matrix -> unit
   

 - val copy :
     matrix -> matrix
   

 - val row :
     matrix -> int -> Gsl_vector.Single.vector
   

 - val add :
     matrix -> matrix -> unit
   

 - val sub :
     matrix -> matrix -> unit
   

 - val mul_elements :
     matrix -> matrix -> unit
   

 - val div_elements :
     matrix -> matrix -> unit
   

 - val scale :
     matrix -> float -> unit
   

 - val add_constant :
     matrix -> float -> unit
   

 - val add_diagonal :
     matrix -> float -> unit
   

 - val is_null :
     matrix -> bool
   

 - val swap_rows :
     matrix -> int -> int -> unit
   

 - val swap_columns :
     matrix -> int -> int -> unit
   

 - val swap_rowcol :
     matrix -> int -> int -> unit
   

 - val transpose :
     matrix -> matrix -> unit
   

 - val transpose_in_place :
     matrix -> unit
   

File: gsl-ocaml.info,  Node: Gsl_matrix_flat,  Next: Gsl_matrix_complex,  Prev: Gsl_matrix,  Up: Top

10 Module `Gsl_matrix_flat'
***************************

10.1 Description
================

Matrices of floats implemented with `float array'

10.2 Interface
==============


 - type double_mat_flat = private {
  data : float array ;
  off : int ;
  dim1 : int ;
  dim2 : int ;
  tda : int ;
 }


 - type matrix = double_mat_flat
   

 - val create :
     ?init:float -> int -> int -> matrix
   

 - val dims :
     matrix -> int * int
   

 - val of_array :
     float array -> int -> int -> matrix
   

 - val of_arrays :
     float array array -> matrix
   

 - val to_array :
     matrix -> float array
   

 - val to_arrays :
     matrix -> float array array
   

 - val to_array :
     matrix -> float array
   

 - val get :
     matrix -> int -> int -> float
   

 - val set :
     matrix -> int -> int -> float -> unit
   

 - val set_all :
     matrix -> float -> unit
   

 - val set_zero :
     matrix -> unit
   

 - val set_id :
     matrix -> unit
   

 - val memcpy :
     src:matrix -> dst:matrix -> unit
   

 - val copy :
     matrix -> matrix
   

 - val add :
     matrix -> matrix -> unit
   

 - val sub :
     matrix -> matrix -> unit
   

 - val mul_elements :
     matrix -> matrix -> unit
   

 - val div_elements :
     matrix -> matrix -> unit
   

 - val scale :
     matrix -> float -> unit
   

 - val add_constant :
     matrix -> float -> unit
   

 - val add_diagonal :
     matrix -> float -> unit
   

 - val is_null :
     matrix -> bool
   

 - val swap_rows :
     matrix -> int -> int -> unit
   

 - val swap_columns :
     matrix -> int -> int -> unit
   

 - val swap_rowcol :
     matrix -> int -> int -> unit
   

 - val transpose :
     matrix -> matrix -> unit
   

 - val transpose_in_place :
     matrix -> unit
   

 - val submatrix :
     matrix ->
       k1:int -> k2:int -> n1:int -> n2:int -> matrix
   

 - val row :
     matrix -> int -> Gsl_vector_flat.vector
   

 - val column :
     matrix -> int -> Gsl_vector_flat.vector
   

 - val diagonal :
     matrix -> Gsl_vector_flat.vector
   

 - val subdiagonal :
     matrix -> int -> Gsl_vector_flat.vector
   

 - val superdiagonal :
     matrix -> int -> Gsl_vector_flat.vector
   

 - val view_array :
     float array -> ?off:int -> int -> ?tda:int -> int -> matrix
   

 - val view_vector :
     Gsl_vector_flat.vector ->
       ?off:int -> int -> ?tda:int -> int -> matrix
   

File: gsl-ocaml.info,  Node: Gsl_matrix_complex,  Next: Gsl_matrix_complex_flat,  Prev: Gsl_matrix_flat,  Up: Top

11 Module `Gsl_matrix_complex'
******************************

11.1 Description
================

Matrices of complex numbers implemented with `Bigarray'

Subparts
========

* Menu:

* Single: Gsl_matrix_complex/Single. Module

11.2 Interface
==============


 - type complex_mat_bigarr = (Complex.t, Bigarray.complex64_elt, Bigarray.c_layout) Bigarray.Array2.t


 - type matrix = complex_mat_bigarr
   

 - val create :
     ?init:Gsl_complex.complex -> int -> int -> matrix
   

 - val dims :
     matrix -> int * int
   

 - val of_array :
     Gsl_complex.complex array -> int -> int -> matrix
   

 - val of_arrays :
     Gsl_complex.complex array array -> matrix
   

 - val to_array :
     matrix -> Gsl_complex.complex array
   

 - val to_arrays :
     matrix -> Gsl_complex.complex array array
   

 - val of_complex_array :
     Gsl_complex.complex_array -> int -> int -> matrix
   

 - val to_complex_array :
     matrix -> Gsl_complex.complex_array
   

 - val get :
     matrix -> int -> int -> Gsl_complex.complex
   

 - val set :
     matrix -> int -> int -> Gsl_complex.complex -> unit
   

 - val set_all :
     matrix -> Gsl_complex.complex -> unit
   

 - val set_zero :
     matrix -> unit
   

 - val set_id :
     matrix -> unit
   

 - val memcpy :
     src:matrix -> dst:matrix -> unit
   

 - val copy :
     matrix -> matrix
   

 - val row :
     matrix -> int -> Gsl_vector_complex.vector
   

 - val add :
     matrix -> matrix -> unit
   

 - val sub :
     matrix -> matrix -> unit
   

 - val mul_elements :
     matrix -> matrix -> unit
   

 - val div_elements :
     matrix -> matrix -> unit
   

 - val scale :
     matrix -> Gsl_complex.complex -> unit
   

 - val add_constant :
     matrix -> Gsl_complex.complex -> unit
   

 - val add_diagonal :
     matrix -> Gsl_complex.complex -> unit
   

 - val is_null :
     matrix -> bool
   

 - val swap_rows :
     matrix -> int -> int -> unit
   

 - val swap_columns :
     matrix -> int -> int -> unit
   

 - val swap_rowcol :
     matrix -> int -> int -> unit
   

 - val transpose :
     matrix -> matrix -> unit
   

 - val transpose_in_place :
     matrix -> unit
   

 - module Single
   *Note Module Single: Gsl_matrix_complex/Single.


File: gsl-ocaml.info,  Node: Gsl_matrix_complex/Single,  Up: Gsl_matrix_complex

11.3 Module `Gsl_matrix_complex.Single'
=======================================

11.3.1 Interface
----------------


 - type complex_float_mat_bigarr = (Complex.t, Bigarray.complex32_elt, Bigarray.c_layout) Bigarray.Array2.t


 - type matrix = complex_float_mat_bigarr
   

 - val create :
     ?init:Gsl_complex.complex -> int -> int -> matrix
   

 - val dims :
     matrix -> int * int
   

 - val of_array :
     Gsl_complex.complex array -> int -> int -> matrix
   

 - val of_arrays :
     Gsl_complex.complex array array -> matrix
   

 - val to_array :
     matrix -> Gsl_complex.complex array
   

 - val to_arrays :
     matrix -> Gsl_complex.complex array array
   

 - val of_complex_array :
     Gsl_complex.complex_array -> int -> int -> matrix
   

 - val to_complex_array :
     matrix -> Gsl_complex.complex_array
   

 - val get :
     matrix -> int -> int -> Gsl_complex.complex
   

 - val set :
     matrix -> int -> int -> Gsl_complex.complex -> unit
   

 - val set_all :
     matrix -> Gsl_complex.complex -> unit
   

 - val set_zero :
     matrix -> unit
   

 - val set_id :
     matrix -> unit
   

 - val memcpy :
     src:matrix ->
       dst:matrix -> unit
   

 - val copy :
     matrix -> matrix
   

 - val row :
     matrix -> int -> Gsl_vector_complex.Single.vector
   

 - val add :
     matrix -> matrix -> unit
   

 - val sub :
     matrix -> matrix -> unit
   

 - val mul_elements :
     matrix -> matrix -> unit
   

 - val div_elements :
     matrix -> matrix -> unit
   

 - val scale :
     matrix -> Gsl_complex.complex -> unit
   

 - val add_constant :
     matrix -> Gsl_complex.complex -> unit
   

 - val add_diagonal :
     matrix -> Gsl_complex.complex -> unit
   

 - val is_null :
     matrix -> bool
   

 - val swap_rows :
     matrix -> int -> int -> unit
   

 - val swap_columns :
     matrix -> int -> int -> unit
   

 - val swap_rowcol :
     matrix -> int -> int -> unit
   

 - val transpose :
     matrix -> matrix -> unit
   

 - val transpose_in_place :
     matrix -> unit
   

File: gsl-ocaml.info,  Node: Gsl_matrix_complex_flat,  Next: Gsl_vectmat,  Prev: Gsl_matrix_complex,  Up: Top

12 Module `Gsl_matrix_complex_flat'
***********************************

12.1 Description
================

Matrices of complex number simplemented with `float array'

12.2 Interface
==============


 - type complex_mat_flat = private {
  data : float array ;
  off : int ;
  dim1 : int ;
  dim2 : int ;
  tda : int ;
 }


 - type matrix = complex_mat_flat
   

 - val create :
     ?init:Gsl_complex.complex -> int -> int -> matrix
   

 - val dims :
     matrix -> int * int
   

 - val of_arrays :
     Gsl_complex.complex array array -> matrix
   

 - val of_array :
     Gsl_complex.complex array -> int -> int -> matrix
   

 - val to_arrays :
     matrix -> Gsl_complex.complex array array
   

 - val to_array :
     matrix -> Gsl_complex.complex array
   

 - val of_complex_array :
     float array -> int -> int -> matrix
   

 - val to_complex_array :
     matrix -> Gsl_complex.complex_array
   

 - val get :
     matrix -> int -> int -> Gsl_complex.complex
   

 - val set :
     matrix -> int -> int -> Gsl_complex.complex -> unit
   

 - val set_all :
     matrix -> Gsl_complex.complex -> unit
   

 - val set_zero :
     matrix -> unit
   

 - val set_id :
     matrix -> unit
   

 - val memcpy :
     src:matrix ->
       dst:matrix -> unit
   

 - val copy :
     matrix -> matrix
   

 - val add :
     matrix -> matrix -> unit
   

 - val sub :
     matrix -> matrix -> unit
   

 - val mul_elements :
     matrix -> matrix -> unit
   

 - val div_elements :
     matrix -> matrix -> unit
   

 - val scale :
     matrix -> float -> unit
   

 - val add_constant :
     matrix -> float -> unit
   

 - val add_diagonal :
     matrix -> Gsl_complex.complex -> unit
   

 - val is_null :
     matrix -> bool
   

 - val swap_rows :
     matrix -> int -> int -> unit
   

 - val swap_columns :
     matrix -> int -> int -> unit
   

 - val swap_rowcol :
     matrix -> int -> int -> unit
   

 - val transpose :
     matrix -> matrix -> unit
   

 - val transpose_in_place :
     matrix -> unit
   

 - val submatrix :
     matrix ->
       k1:int -> k2:int -> n1:int -> n2:int -> matrix
   

 - val row :
     matrix -> int -> Gsl_vector_complex_flat.vector
   

 - val column :
     matrix -> int -> Gsl_vector_complex_flat.vector
   

 - val diagonal :
     matrix -> Gsl_vector_complex_flat.vector
   

 - val subdiagonal :
     matrix -> int -> Gsl_vector_complex_flat.vector
   

 - val superdiagonal :
     matrix -> int -> Gsl_vector_complex_flat.vector
   

 - val view_complex_array :
     Gsl_complex.complex_array ->
       ?off:int -> int -> ?tda:int -> int -> matrix
   

 - val view_vector :
     Gsl_vector_complex_flat.vector ->
       ?off:int -> int -> ?tda:int -> int -> matrix
   

File: gsl-ocaml.info,  Node: Gsl_vectmat,  Next: Gsl_blas,  Prev: Gsl_matrix_complex_flat,  Up: Top

13 Module `Gsl_vectmat'
***********************

13.1 Description
================

Generic variant types for vectors and matrices

13.2 Interface
==============

13.2.1 Real values
------------------


 - type vec = [ `V of Gsl_vector.vector | `VF of Gsl_vector_flat.vector ]


 - val vec_convert :
     ?protect:bool ->
       [< `A of float array
        | `V of Gsl_vector.vector
        | `VF of Gsl_vector_flat.vector ] ->
       [> vec ]
   

 - type mat = [ `M of Gsl_matrix.matrix | `MF of Gsl_matrix_flat.matrix ]
   

 - val mat_convert :
     ?protect:bool ->
       [< `A of float array * int * int
        | `AA of float array array
        | `M of Gsl_matrix.matrix
        | `MF of Gsl_matrix_flat.matrix ] ->
       [> mat ]
   

 - val mat_flat :
     ?protect:bool ->
       [< `A of float array * int * int
        | `AA of float array array
        | `M of Gsl_matrix.matrix
        | `MF of Gsl_matrix_flat.matrix ] ->
       Gsl_matrix_flat.matrix
   
13.2.2 Complex values
---------------------


 - type cvec = [ `CV of Gsl_vector_complex.vector | `CVF of Gsl_vector_complex_flat.vector ]


 - type cmat = [ `CM of Gsl_matrix_complex.matrix | `CMF of Gsl_matrix_complex_flat.matrix ]
   

 - val cmat_convert :
     ?protect:bool ->
       [< `CA of Gsl_complex.complex_array * int * int
        | `CM of Gsl_matrix_complex.matrix
        | `CMF of Gsl_matrix_complex_flat.matrix ] ->
       [> cmat ]
   
13.2.3 Generic vector operations
--------------------------------


 - val length :
     [< `CV of Gsl_vector_complex.vector
        | `CVF of Gsl_vector_complex_flat.vector
        | `V of Gsl_vector.vector
        | `VF of Gsl_vector_flat.vector ] ->
       int


 - val to_array :
     [< vec ] -> float array
   

 - val v_copy :
     [< vec ] -> [> vec ]
   

 - val subvector :
     [< vec ] -> off:int -> len:int -> [> vec ]
   

 - val v_memcpy :
     [< vec ] -> [< vec ] -> unit
   

 - val v_add :
     [< vec ] -> [< vec ] -> unit
   

 - val v_sub :
     [< vec ] -> [< vec ] -> unit
   

 - val v_mul :
     [< vec ] -> [< vec ] -> unit
   

 - val v_div :
     [< vec ] -> [< vec ] -> unit
   

 - val v_max :
     [< vec ] -> float
   

 - val v_min :
     [< vec ] -> float
   

 - val v_minmax :
     [< vec ] -> float * float
   

 - val v_max_index :
     [< vec ] -> int
   

 - val v_min_index :
     [< vec ] -> int
   

 - val v_minmax_index :
     [< vec ] -> int * int
   
13.2.4 Generic matrix operations
--------------------------------


 - val dims :
     [< `CM of Gsl_matrix_complex.matrix
        | `CMF of Gsl_matrix_complex_flat.matrix
        | `M of Gsl_matrix.matrix
        | `MF of Gsl_matrix_flat.matrix ] ->
       int * int


 - val tmp :
     [< mat ] -> [> `M of Gsl_matrix.matrix ]
   

 - val to_arrays :
     [< mat ] -> float array array
   

 - val m_copy :
     [< mat ] -> [> mat ]
   

 - val m_memcpy :
     [< mat ] -> [< mat ] -> unit
   

 - val m_add :
     [< mat ] -> [< mat ] -> unit
   

 - val m_sub :
     [< mat ] -> [< mat ] -> unit
   

 - val m_mul :
     [< mat ] -> [< mat ] -> unit
   

 - val m_div :
     [< mat ] -> [< mat ] -> unit
   

 - val m_add_diagonal :
     [< mat ] -> float -> unit
   

 - val swap_rows :
     [< mat ] -> int -> int -> unit
   

 - val swap_columns :
     [< mat ] -> int -> int -> unit
   

 - val swap_rowcol :
     [< mat ] -> int -> int -> unit
   

 - val transpose :
     [< mat ] -> [< mat ] -> unit
   

 - val transpose_in_place :
     [< mat ] -> unit
   
13.2.5 Other generic operations
-------------------------------


 - val is_null :
     [< `M of Gsl_matrix.matrix
        | `MF of Gsl_matrix_flat.matrix
        | `V of Gsl_vector.vector
        | `VF of Gsl_vector_flat.vector ] ->
       bool


 - val scale :
     [< `M of Gsl_matrix.matrix
        | `MF of Gsl_matrix_flat.matrix
        | `V of Gsl_vector.vector
        | `VF of Gsl_vector_flat.vector ] ->
       float -> unit
   

 - val add_constant :
     [< `M of Gsl_matrix.matrix
        | `MF of Gsl_matrix_flat.matrix
        | `V of Gsl_vector.vector
        | `VF of Gsl_vector_flat.vector ] ->
       float -> unit
   

File: gsl-ocaml.info,  Node: Gsl_blas,  Next: Gsl_blas_flat,  Prev: Gsl_vectmat,  Up: Top

14 Module `Gsl_blas'
********************

14.1 Description
================

BLAS support

Subparts
========

* Menu:

* Single: Gsl_blas/Single.         Module
* Complex: Gsl_blas/Complex.       Module
* Complex_Single: Gsl_blas/Complex_Single. Module

14.2 Interface
==============


 - type order =
  | RowMajor
  | ColMajor


 - type transpose =
  | NoTrans
  | Trans
  | ConjTrans
   

 - type uplo =
  | Upper
  | Lower
   

 - type diag =
  | NonUnit
  | Unit
   

 - type side =
  | Left
  | Right
   
14.2.1 LEVEL 1
--------------


 - val dot :
     Gsl_vector.vector -> Gsl_vector.vector -> float


 - val nrm2 :
     Gsl_vector.vector -> float
   

 - val asum :
     Gsl_vector.vector -> float
   

 - val iamax :
     Gsl_vector.vector -> int
   

 - val swap :
     Gsl_vector.vector -> Gsl_vector.vector -> unit
   

 - val copy :
     Gsl_vector.vector -> Gsl_vector.vector -> unit
   

 - val axpy :
     float -> Gsl_vector.vector -> Gsl_vector.vector -> unit
   

 - val rot :
     Gsl_vector.vector -> Gsl_vector.vector -> float -> float -> unit
   

 - val scal :
     float -> Gsl_vector.vector -> unit
   
14.2.2 LEVEL 2
--------------


 - val gemv :
     transpose ->
       alpha:float ->
       a:Gsl_matrix.matrix ->
       x:Gsl_vector.vector -> beta:float -> y:Gsl_vector.vector -> unit


 - val trmv :
     uplo ->
       transpose ->
       diag -> a:Gsl_matrix.matrix -> x:Gsl_vector.vector -> unit
   

 - val trsv :
     uplo ->
       transpose ->
       diag -> a:Gsl_matrix.matrix -> x:Gsl_vector.vector -> unit
   

 - val symv :
     uplo ->
       alpha:float ->
       a:Gsl_matrix.matrix ->
       x:Gsl_vector.vector -> beta:float -> y:Gsl_vector.vector -> unit
   

 - val dger :
     alpha:float ->
       x:Gsl_vector.vector -> y:Gsl_vector.vector -> a:Gsl_matrix.matrix -> unit
   

 - val syr :
     uplo ->
       alpha:float -> x:Gsl_vector.vector -> a:Gsl_matrix.matrix -> unit
   

 - val syr2 :
     uplo ->
       alpha:float ->
       x:Gsl_vector.vector -> y:Gsl_vector.vector -> a:Gsl_matrix.matrix -> unit
   
14.2.3 LEVEL 3
--------------


 - val gemm :
     ta:transpose ->
       tb:transpose ->
       alpha:float ->
       a:Gsl_matrix.matrix ->
       b:Gsl_matrix.matrix -> beta:float -> c:Gsl_matrix.matrix -> unit


 - val symm :
     side ->
       uplo ->
       alpha:float ->
       a:Gsl_matrix.matrix ->
       b:Gsl_matrix.matrix -> beta:float -> c:Gsl_matrix.matrix -> unit
   

 - val trmm :
     side ->
       uplo ->
       transpose ->
       diag ->
       alpha:float -> a:Gsl_matrix.matrix -> b:Gsl_matrix.matrix -> unit
   

 - val trsm :
     side ->
       uplo ->
       transpose ->
       diag ->
       alpha:float -> a:Gsl_matrix.matrix -> b:Gsl_matrix.matrix -> unit
   

 - val syrk :
     uplo ->
       transpose ->
       alpha:float ->
       a:Gsl_matrix.matrix -> beta:float -> c:Gsl_matrix.matrix -> unit
   

 - val syr2k :
     uplo ->
       transpose ->
       alpha:float ->
       a:Gsl_matrix.matrix ->
       b:Gsl_matrix.matrix -> beta:float -> c:Gsl_matrix.matrix -> unit
   
14.2.4 Single precision
-----------------------


 - module Single
*Note Module Single: Gsl_blas/Single.

14.2.5 Complex
--------------


 - module Complex
*Note Module Complex: Gsl_blas/Complex.

14.2.6 Complex single precision
-------------------------------


 - module Complex_Single
*Note Module Complex_Single: Gsl_blas/Complex_Single.


File: gsl-ocaml.info,  Node: Gsl_blas/Single,  Next: Gsl_blas/Complex,  Up: Gsl_blas

14.3 Module `Gsl_blas.Single'
=============================

14.3.1 Interface
----------------

14.3.1.1 LEVEL 1
................


 - val sdsdot :
     alpha:float -> Gsl_vector.Single.vector -> Gsl_vector.Single.vector -> float


 - val dsdot :
     Gsl_vector.Single.vector -> Gsl_vector.Single.vector -> float
   

 - val dot :
     Gsl_vector.Single.vector -> Gsl_vector.Single.vector -> float
   

 - val nrm2 :
     Gsl_vector.Single.vector -> float
   

 - val asum :
     Gsl_vector.Single.vector -> float
   

 - val iamax :
     Gsl_vector.Single.vector -> int
   

 - val swap :
     Gsl_vector.Single.vector -> Gsl_vector.Single.vector -> unit
   

 - val copy :
     Gsl_vector.Single.vector -> Gsl_vector.Single.vector -> unit
   

 - val axpy :
     float -> Gsl_vector.Single.vector -> Gsl_vector.Single.vector -> unit
   

 - val rot :
     Gsl_vector.Single.vector ->
       Gsl_vector.Single.vector -> float -> float -> unit
   

 - val scal :
     float -> Gsl_vector.Single.vector -> unit
   
14.3.1.2 LEVEL 2
................


 - val gemv :
     Gsl_blas.transpose ->
       alpha:float ->
       a:Gsl_matrix.Single.matrix ->
       x:Gsl_vector.Single.vector ->
       beta:float -> y:Gsl_vector.Single.vector -> unit


 - val trmv :
     Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       Gsl_blas.diag ->
       a:Gsl_matrix.Single.matrix -> x:Gsl_vector.Single.vector -> unit
   

 - val trsv :
     Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       Gsl_blas.diag ->
       a:Gsl_matrix.Single.matrix -> x:Gsl_vector.Single.vector -> unit
   

 - val symv :
     Gsl_blas.uplo ->
       alpha:float ->
       a:Gsl_matrix.Single.matrix ->
       x:Gsl_vector.Single.vector ->
       beta:float -> y:Gsl_vector.Single.vector -> unit
   

 - val dger :
     alpha:float ->
       x:Gsl_vector.Single.vector ->
       y:Gsl_vector.Single.vector -> a:Gsl_matrix.Single.matrix -> unit
   

 - val syr :
     Gsl_blas.uplo ->
       alpha:float ->
       x:Gsl_vector.Single.vector -> a:Gsl_matrix.Single.matrix -> unit
   

 - val syr2 :
     Gsl_blas.uplo ->
       alpha:float ->
       x:Gsl_vector.Single.vector ->
       y:Gsl_vector.Single.vector -> a:Gsl_matrix.Single.matrix -> unit
   
14.3.1.3 LEVEL 3
................


 - val gemm :
     ta:Gsl_blas.transpose ->
       tb:Gsl_blas.transpose ->
       alpha:float ->
       a:Gsl_matrix.Single.matrix ->
       b:Gsl_matrix.Single.matrix ->
       beta:float -> c:Gsl_matrix.Single.matrix -> unit


 - val symm :
     Gsl_blas.side ->
       Gsl_blas.uplo ->
       alpha:float ->
       a:Gsl_matrix.Single.matrix ->
       b:Gsl_matrix.Single.matrix ->
       beta:float -> c:Gsl_matrix.Single.matrix -> unit
   

 - val syrk :
     Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       alpha:float ->
       a:Gsl_matrix.Single.matrix ->
       beta:float -> c:Gsl_matrix.Single.matrix -> unit
   

 - val syr2k :
     Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       alpha:float ->
       a:Gsl_matrix.Single.matrix ->
       b:Gsl_matrix.Single.matrix ->
       beta:float -> c:Gsl_matrix.Single.matrix -> unit
   

 - val trmm :
     Gsl_blas.side ->
       Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       Gsl_blas.diag ->
       alpha:float ->
       a:Gsl_matrix.Single.matrix -> b:Gsl_matrix.Single.matrix -> unit
   

 - val trsm :
     Gsl_blas.side ->
       Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       Gsl_blas.diag ->
       alpha:float ->
       a:Gsl_matrix.Single.matrix -> b:Gsl_matrix.Single.matrix -> unit
   

File: gsl-ocaml.info,  Node: Gsl_blas/Complex,  Next: Gsl_blas/Complex_Single,  Prev: Gsl_blas/Single,  Up: Gsl_blas

14.4 Module `Gsl_blas.Complex'
==============================

14.4.1 Interface
----------------

14.4.1.1 LEVEL 1
................


 - val dotu :
     Gsl_vector_complex.vector -> Gsl_vector_complex.vector -> Gsl_complex.complex


 - val dotc :
     Gsl_vector_complex.vector -> Gsl_vector_complex.vector -> Gsl_complex.complex
   

 - val nrm2 :
     Gsl_vector_complex.vector -> float
   

 - val asum :
     Gsl_vector_complex.vector -> float
   

 - val iamax :
     Gsl_vector_complex.vector -> int
   

 - val swap :
     Gsl_vector_complex.vector -> Gsl_vector_complex.vector -> unit
   

 - val copy :
     Gsl_vector_complex.vector -> Gsl_vector_complex.vector -> unit
   

 - val axpy :
     Gsl_complex.complex ->
       Gsl_vector_complex.vector -> Gsl_vector_complex.vector -> unit
   

 - val scal :
     Gsl_complex.complex -> Gsl_vector_complex.vector -> unit
   

 - val zdscal :
     float -> Gsl_vector_complex.vector -> unit
   
14.4.1.2 LEVEL 2
................


 - val gemv :
     Gsl_blas.transpose ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.matrix ->
       x:Gsl_vector_complex.vector ->
       beta:Gsl_complex.complex -> y:Gsl_vector_complex.vector -> unit


 - val trmv :
     Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       Gsl_blas.diag ->
       a:Gsl_matrix_complex.matrix -> x:Gsl_vector_complex.vector -> unit
   

 - val trsv :
     Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       Gsl_blas.diag ->
       a:Gsl_matrix_complex.matrix -> x:Gsl_vector_complex.vector -> unit
   

 - val hemv :
     Gsl_blas.uplo ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.matrix ->
       x:Gsl_vector_complex.vector ->
       beta:Gsl_complex.complex -> y:Gsl_vector_complex.vector -> unit
   

 - val geru :
     alpha:Gsl_complex.complex ->
       x:Gsl_vector_complex.vector ->
       y:Gsl_vector_complex.vector -> a:Gsl_matrix_complex.matrix -> unit
   

 - val gerc :
     alpha:Gsl_complex.complex ->
       x:Gsl_vector_complex.vector ->
       y:Gsl_vector_complex.vector -> a:Gsl_matrix_complex.matrix -> unit
   

 - val her :
     Gsl_blas.uplo ->
       alpha:float ->
       x:Gsl_vector_complex.vector -> a:Gsl_matrix_complex.matrix -> unit
   

 - val her2 :
     Gsl_blas.uplo ->
       alpha:Gsl_complex.complex ->
       x:Gsl_vector_complex.vector ->
       y:Gsl_vector_complex.vector -> a:Gsl_matrix_complex.matrix -> unit
   
14.4.1.3 LEVEL 3
................


 - val gemm :
     ta:Gsl_blas.transpose ->
       tb:Gsl_blas.transpose ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.matrix ->
       b:Gsl_matrix_complex.matrix ->
       beta:Gsl_complex.complex -> c:Gsl_matrix_complex.matrix -> unit


 - val symm :
     Gsl_blas.side ->
       Gsl_blas.uplo ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.matrix ->
       b:Gsl_matrix_complex.matrix ->
       beta:Gsl_complex.complex -> c:Gsl_matrix_complex.matrix -> unit
   

 - val syrk :
     Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.matrix ->
       beta:Gsl_complex.complex -> c:Gsl_matrix_complex.matrix -> unit
   

 - val syr2k :
     Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.matrix ->
       b:Gsl_matrix_complex.matrix ->
       beta:Gsl_complex.complex -> c:Gsl_matrix_complex.matrix -> unit
   

 - val trmm :
     Gsl_blas.side ->
       Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       Gsl_blas.diag ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.matrix -> b:Gsl_matrix_complex.matrix -> unit
   

 - val trsm :
     Gsl_blas.side ->
       Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       Gsl_blas.diag ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.matrix -> b:Gsl_matrix_complex.matrix -> unit
   

 - val hemm :
     Gsl_blas.side ->
       Gsl_blas.uplo ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.matrix ->
       b:Gsl_matrix_complex.matrix ->
       beta:Gsl_complex.complex -> c:Gsl_matrix_complex.matrix -> unit
   

 - val herk :
     Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       alpha:float ->
       a:Gsl_matrix_complex.matrix ->
       beta:float -> c:Gsl_matrix_complex.matrix -> unit
   

 - val her2k :
     Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.matrix ->
       b:Gsl_matrix_complex.matrix ->
       beta:float -> c:Gsl_matrix_complex.matrix -> unit
   

File: gsl-ocaml.info,  Node: Gsl_blas/Complex_Single,  Prev: Gsl_blas/Complex,  Up: Gsl_blas

14.5 Module `Gsl_blas.Complex_Single'
=====================================

14.5.1 Interface
----------------

14.5.1.1 LEVEL 1
................


 - val dotu :
     Gsl_vector_complex.Single.vector ->
       Gsl_vector_complex.Single.vector -> Gsl_complex.complex


 - val dotc :
     Gsl_vector_complex.Single.vector ->
       Gsl_vector_complex.Single.vector -> Gsl_complex.complex
   

 - val nrm2 :
     Gsl_vector_complex.Single.vector -> float
   

 - val asum :
     Gsl_vector_complex.Single.vector -> float
   

 - val iamax :
     Gsl_vector_complex.Single.vector -> int
   

 - val swap :
     Gsl_vector_complex.Single.vector -> Gsl_vector_complex.Single.vector -> unit
   

 - val copy :
     Gsl_vector_complex.Single.vector -> Gsl_vector_complex.Single.vector -> unit
   

 - val axpy :
     Gsl_complex.complex ->
       Gsl_vector_complex.Single.vector -> Gsl_vector_complex.Single.vector -> unit
   

 - val scal :
     Gsl_complex.complex -> Gsl_vector_complex.Single.vector -> unit
   

 - val csscal :
     float -> Gsl_vector_complex.Single.vector -> unit
   
14.5.1.2 LEVEL 2
................


 - val gemv :
     Gsl_blas.transpose ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.Single.matrix ->
       x:Gsl_vector_complex.Single.vector ->
       beta:Gsl_complex.complex -> y:Gsl_vector_complex.Single.vector -> unit


 - val trmv :
     Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       Gsl_blas.diag ->
       a:Gsl_matrix_complex.Single.matrix ->
       x:Gsl_vector_complex.Single.vector -> unit
   

 - val trsv :
     Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       Gsl_blas.diag ->
       a:Gsl_matrix_complex.Single.matrix ->
       x:Gsl_vector_complex.Single.vector -> unit
   

 - val hemv :
     Gsl_blas.uplo ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.Single.matrix ->
       x:Gsl_vector_complex.Single.vector ->
       beta:Gsl_complex.complex -> y:Gsl_vector_complex.Single.vector -> unit
   

 - val geru :
     alpha:Gsl_complex.complex ->
       x:Gsl_vector_complex.Single.vector ->
       y:Gsl_vector_complex.Single.vector ->
       a:Gsl_matrix_complex.Single.matrix -> unit
   

 - val gerc :
     alpha:Gsl_complex.complex ->
       x:Gsl_vector_complex.Single.vector ->
       y:Gsl_vector_complex.Single.vector ->
       a:Gsl_matrix_complex.Single.matrix -> unit
   

 - val her :
     Gsl_blas.uplo ->
       alpha:float ->
       x:Gsl_vector_complex.Single.vector ->
       a:Gsl_matrix_complex.Single.matrix -> unit
   

 - val her2 :
     Gsl_blas.uplo ->
       alpha:Gsl_complex.complex ->
       x:Gsl_vector_complex.Single.vector ->
       y:Gsl_vector_complex.Single.vector ->
       a:Gsl_matrix_complex.Single.matrix -> unit
   
14.5.1.3 LEVEL 3
................


 - val gemm :
     ta:Gsl_blas.transpose ->
       tb:Gsl_blas.transpose ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.Single.matrix ->
       b:Gsl_matrix_complex.Single.matrix ->
       beta:Gsl_complex.complex -> c:Gsl_matrix_complex.Single.matrix -> unit


 - val symm :
     Gsl_blas.side ->
       Gsl_blas.uplo ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.Single.matrix ->
       b:Gsl_matrix_complex.Single.matrix ->
       beta:Gsl_complex.complex -> c:Gsl_matrix_complex.Single.matrix -> unit
   

 - val syrk :
     Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.Single.matrix ->
       beta:Gsl_complex.complex -> c:Gsl_matrix_complex.Single.matrix -> unit
   

 - val syr2k :
     Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.Single.matrix ->
       b:Gsl_matrix_complex.Single.matrix ->
       beta:Gsl_complex.complex -> c:Gsl_matrix_complex.Single.matrix -> unit
   

 - val trmm :
     Gsl_blas.side ->
       Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       Gsl_blas.diag ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.Single.matrix ->
       b:Gsl_matrix_complex.Single.matrix -> unit
   

 - val trsm :
     Gsl_blas.side ->
       Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       Gsl_blas.diag ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.Single.matrix ->
       b:Gsl_matrix_complex.Single.matrix -> unit
   

 - val hemm :
     Gsl_blas.side ->
       Gsl_blas.uplo ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.Single.matrix ->
       b:Gsl_matrix_complex.Single.matrix ->
       beta:Gsl_complex.complex -> c:Gsl_matrix_complex.Single.matrix -> unit
   

 - val herk :
     Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       alpha:float ->
       a:Gsl_matrix_complex.Single.matrix ->
       beta:float -> c:Gsl_matrix_complex.Single.matrix -> unit
   

 - val her2k :
     Gsl_blas.uplo ->
       Gsl_blas.transpose ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex.Single.matrix ->
       b:Gsl_matrix_complex.Single.matrix ->
       beta:float -> c:Gsl_matrix_complex.Single.matrix -> unit
   

File: gsl-ocaml.info,  Node: Gsl_blas_flat,  Next: Gsl_blas_gen,  Prev: Gsl_blas,  Up: Top

15 Module `Gsl_blas_flat'
*************************

Subparts
========

* Menu:

* Complex: Gsl_blas_flat/Complex.  Module

15.1 Interface
==============


 - type order = Gsl_blas.order =
  | RowMajor
  | ColMajor


 - type transpose = Gsl_blas.transpose =
  | NoTrans
  | Trans
  | ConjTrans
   

 - type uplo = Gsl_blas.uplo =
  | Upper
  | Lower
   

 - type diag = Gsl_blas.diag =
  | NonUnit
  | Unit
   

 - type side = Gsl_blas.side =
  | Left
  | Right
   

 - val dot :
     Gsl_vector_flat.vector -> Gsl_vector_flat.vector -> float
   

 - val nrm2 :
     Gsl_vector_flat.vector -> float
   

 - val asum :
     Gsl_vector_flat.vector -> float
   

 - val iamax :
     Gsl_vector_flat.vector -> int
   

 - val swap :
     Gsl_vector_flat.vector -> Gsl_vector_flat.vector -> unit
   

 - val copy :
     Gsl_vector_flat.vector -> Gsl_vector_flat.vector -> unit
   

 - val axpy :
     float -> Gsl_vector_flat.vector -> Gsl_vector_flat.vector -> unit
   

 - val rot :
     Gsl_vector_flat.vector -> Gsl_vector_flat.vector -> float -> float -> unit
   

 - val scal :
     float -> Gsl_vector_flat.vector -> unit
   

 - val gemv :
     transpose ->
       alpha:float ->
       a:Gsl_matrix_flat.matrix ->
       x:Gsl_vector_flat.vector -> beta:float -> y:Gsl_vector_flat.vector -> unit
   

 - val trmv :
     uplo ->
       transpose ->
       diag ->
       a:Gsl_matrix_flat.matrix -> x:Gsl_vector_flat.vector -> unit
   

 - val trsv :
     uplo ->
       transpose ->
       diag ->
       a:Gsl_matrix_flat.matrix -> x:Gsl_vector_flat.vector -> unit
   

 - val symv :
     uplo ->
       alpha:float ->
       a:Gsl_matrix_flat.matrix ->
       x:Gsl_vector_flat.vector -> beta:float -> y:Gsl_vector_flat.vector -> unit
   

 - val dger :
     alpha:float ->
       x:Gsl_vector_flat.vector ->
       y:Gsl_vector_flat.vector -> a:Gsl_matrix_flat.matrix -> unit
   

 - val syr :
     uplo ->
       alpha:float -> x:Gsl_vector_flat.vector -> a:Gsl_matrix_flat.matrix -> unit
   

 - val syr2 :
     uplo ->
       alpha:float ->
       x:Gsl_vector_flat.vector ->
       y:Gsl_vector_flat.vector -> a:Gsl_matrix_flat.matrix -> unit
   

 - val gemm :
     ta:transpose ->
       tb:transpose ->
       alpha:float ->
       a:Gsl_matrix_flat.matrix ->
       b:Gsl_matrix_flat.matrix -> beta:float -> c:Gsl_matrix_flat.matrix -> unit
   

 - val symm :
     side ->
       uplo ->
       alpha:float ->
       a:Gsl_matrix_flat.matrix ->
       b:Gsl_matrix_flat.matrix -> beta:float -> c:Gsl_matrix_flat.matrix -> unit
   

 - val trmm :
     side ->
       uplo ->
       transpose ->
       diag ->
       alpha:float -> a:Gsl_matrix_flat.matrix -> b:Gsl_matrix_flat.matrix -> unit
   

 - val trsm :
     side ->
       uplo ->
       transpose ->
       diag ->
       alpha:float -> a:Gsl_matrix_flat.matrix -> b:Gsl_matrix_flat.matrix -> unit
   

 - val syrk :
     uplo ->
       transpose ->
       alpha:float ->
       a:Gsl_matrix_flat.matrix -> beta:float -> c:Gsl_matrix_flat.matrix -> unit
   

 - val syr2k :
     uplo ->
       transpose ->
       alpha:float ->
       a:Gsl_matrix_flat.matrix ->
       b:Gsl_matrix_flat.matrix -> beta:float -> c:Gsl_matrix_flat.matrix -> unit
   

 - module Complex
   *Note Module Complex: Gsl_blas_flat/Complex.


File: gsl-ocaml.info,  Node: Gsl_blas_flat/Complex,  Up: Gsl_blas_flat

15.2 Module `Gsl_blas_flat.Complex'
===================================

15.2.1 Interface
----------------


 - val dotu :
     Gsl_vector_complex_flat.vector ->
       Gsl_vector_complex_flat.vector -> Gsl_complex.complex


 - val dotc :
     Gsl_vector_complex_flat.vector ->
       Gsl_vector_complex_flat.vector -> Gsl_complex.complex
   

 - val nrm2 :
     Gsl_vector_complex_flat.vector -> float
   

 - val asum :
     Gsl_vector_complex_flat.vector -> float
   

 - val iamax :
     Gsl_vector_complex_flat.vector -> int
   

 - val swap :
     Gsl_vector_complex_flat.vector -> Gsl_vector_complex_flat.vector -> unit
   

 - val copy :
     Gsl_vector_complex_flat.vector -> Gsl_vector_complex_flat.vector -> unit
   

 - val axpy :
     Gsl_complex.complex ->
       Gsl_vector_complex_flat.vector -> Gsl_vector_complex_flat.vector -> unit
   

 - val scal :
     Gsl_complex.complex -> Gsl_vector_complex_flat.vector -> unit
   

 - val zdscal :
     float -> Gsl_vector_complex_flat.vector -> unit
   

 - val gemv :
     Gsl_blas_flat.transpose ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex_flat.matrix ->
       x:Gsl_vector_complex_flat.vector ->
       beta:Gsl_complex.complex -> y:Gsl_vector_complex_flat.vector -> unit
   

 - val trmv :
     Gsl_blas_flat.uplo ->
       Gsl_blas_flat.transpose ->
       Gsl_blas_flat.diag ->
       a:Gsl_matrix_complex_flat.matrix -> x:Gsl_vector_complex_flat.vector -> unit
   

 - val trsv :
     Gsl_blas_flat.uplo ->
       Gsl_blas_flat.transpose ->
       Gsl_blas_flat.diag ->
       a:Gsl_matrix_complex_flat.matrix -> x:Gsl_vector_complex_flat.vector -> unit
   

 - val hemv :
     Gsl_blas_flat.uplo ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex_flat.matrix ->
       x:Gsl_vector_complex_flat.vector ->
       beta:Gsl_complex.complex -> y:Gsl_vector_complex_flat.vector -> unit
   

 - val geru :
     alpha:Gsl_complex.complex ->
       x:Gsl_vector_complex_flat.vector ->
       y:Gsl_vector_complex_flat.vector -> a:Gsl_matrix_complex_flat.matrix -> unit
   

 - val gerc :
     alpha:Gsl_complex.complex ->
       x:Gsl_vector_complex_flat.vector ->
       y:Gsl_vector_complex_flat.vector -> a:Gsl_matrix_complex_flat.matrix -> unit
   

 - val her :
     Gsl_blas_flat.uplo ->
       alpha:float ->
       x:Gsl_vector_complex_flat.vector -> a:Gsl_matrix_complex_flat.matrix -> unit
   

 - val her2 :
     Gsl_blas_flat.uplo ->
       alpha:Gsl_complex.complex ->
       x:Gsl_vector_complex_flat.vector ->
       y:Gsl_vector_complex_flat.vector -> a:Gsl_matrix_complex_flat.matrix -> unit
   

 - val gemm :
     ta:Gsl_blas_flat.transpose ->
       tb:Gsl_blas_flat.transpose ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex_flat.matrix ->
       b:Gsl_matrix_complex_flat.matrix ->
       beta:Gsl_complex.complex -> c:Gsl_matrix_complex_flat.matrix -> unit
   

 - val symm :
     Gsl_blas_flat.side ->
       Gsl_blas_flat.uplo ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex_flat.matrix ->
       b:Gsl_matrix_complex_flat.matrix ->
       beta:Gsl_complex.complex -> c:Gsl_matrix_complex_flat.matrix -> unit
   

 - val syrk :
     Gsl_blas_flat.uplo ->
       Gsl_blas_flat.transpose ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex_flat.matrix ->
       beta:Gsl_complex.complex -> c:Gsl_matrix_complex_flat.matrix -> unit
   

 - val syr2k :
     Gsl_blas_flat.uplo ->
       Gsl_blas_flat.transpose ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex_flat.matrix ->
       b:Gsl_matrix_complex_flat.matrix ->
       beta:Gsl_complex.complex -> c:Gsl_matrix_complex_flat.matrix -> unit
   

 - val trmm :
     Gsl_blas_flat.side ->
       Gsl_blas_flat.uplo ->
       Gsl_blas_flat.transpose ->
       Gsl_blas_flat.diag ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex_flat.matrix -> b:Gsl_matrix_complex_flat.matrix -> unit
   

 - val trsm :
     Gsl_blas_flat.side ->
       Gsl_blas_flat.uplo ->
       Gsl_blas_flat.transpose ->
       Gsl_blas_flat.diag ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex_flat.matrix -> b:Gsl_matrix_complex_flat.matrix -> unit
   

 - val hemm :
     Gsl_blas_flat.side ->
       Gsl_blas_flat.uplo ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex_flat.matrix ->
       b:Gsl_matrix_complex_flat.matrix ->
       beta:Gsl_complex.complex -> c:Gsl_matrix_complex_flat.matrix -> unit
   

 - val herk :
     Gsl_blas_flat.uplo ->
       Gsl_blas_flat.transpose ->
       alpha:float ->
       a:Gsl_matrix_complex_flat.matrix ->
       beta:float -> c:Gsl_matrix_complex_flat.matrix -> unit
   

 - val her2k :
     Gsl_blas_flat.uplo ->
       Gsl_blas_flat.transpose ->
       alpha:Gsl_complex.complex ->
       a:Gsl_matrix_complex_flat.matrix ->
       b:Gsl_matrix_complex_flat.matrix ->
       beta:float -> c:Gsl_matrix_complex_flat.matrix -> unit
   

File: gsl-ocaml.info,  Node: Gsl_blas_gen,  Next: Gsl_fun,  Prev: Gsl_blas_flat,  Up: Top

16 Module `Gsl_blas_gen'
************************

Subparts
========

* Menu:

* Complex: Gsl_blas_gen/Complex.   Module

16.1 Interface
==============


 - type order = Gsl_blas.order =
  | RowMajor
  | ColMajor


 - type transpose = Gsl_blas.transpose =
  | NoTrans
  | Trans
  | ConjTrans
   

 - type uplo = Gsl_blas.uplo =
  | Upper
  | Lower
   

 - type diag = Gsl_blas.diag =
  | NonUnit
  | Unit
   

 - type side = Gsl_blas.side =
  | Left
  | Right
   

 - val dot :
     [< Gsl_vectmat.vec ] -> [< Gsl_vectmat.vec ] -> float
   

 - val nrm2 :
     [< Gsl_vectmat.vec ] -> float
   

 - val asum :
     [< Gsl_vectmat.vec ] -> float
   

 - val iamax :
     [< Gsl_vectmat.vec ] -> int
   

 - val swap :
     [< Gsl_vectmat.vec ] -> [< Gsl_vectmat.vec ] -> unit
   

 - val copy :
     [< Gsl_vectmat.vec ] -> [< Gsl_vectmat.vec ] -> unit
   

 - val axpy :
     float -> [< Gsl_vectmat.vec ] -> [< Gsl_vectmat.vec ] -> unit
   

 - val rot :
     [< Gsl_vectmat.vec ] -> [< Gsl_vectmat.vec ] -> float -> float -> unit
   

 - val scal :
     float -> [< Gsl_vectmat.vec ] -> unit
   

 - val gemv :
     transpose ->
       alpha:float ->
       a:[< Gsl_vectmat.mat ] ->
       x:[< Gsl_vectmat.vec ] -> beta:float -> y:[< Gsl_vectmat.vec ] -> unit
   

 - val trmv :
     uplo ->
       transpose ->
       diag -> a:[< Gsl_vectmat.mat ] -> x:[< Gsl_vectmat.vec ] -> unit
   

 - val trsv :
     uplo ->
       transpose ->
       diag -> a:[< Gsl_vectmat.mat ] -> x:[< Gsl_vectmat.vec ] -> unit
   

 - val symv :
     uplo ->
       alpha:float ->
       a:[< Gsl_vectmat.mat ] ->
       x:[< Gsl_vectmat.vec ] -> beta:float -> y:[< Gsl_vectmat.vec ] -> unit
   

 - val dger :
     alpha:float ->
       x:[< Gsl_vectmat.vec ] ->
       y:[< Gsl_vectmat.vec ] -> a:[< Gsl_vectmat.mat ] -> unit
   

 - val syr :
     uplo ->
       alpha:float -> x:[< Gsl_vectmat.vec ] -> a:[< Gsl_vectmat.mat ] -> unit
   

 - val syr2 :
     uplo ->
       alpha:float ->
       x:[< Gsl_vectmat.vec ] ->
       y:[< Gsl_vectmat.vec ] -> a:[< Gsl_vectmat.mat ] -> unit
   

 - val gemm :
     ta:transpose ->
       tb:transpose ->
       alpha:float ->
       a:[< Gsl_vectmat.mat ] ->
       b:[< Gsl_vectmat.mat ] -> beta:float -> c:[< Gsl_vectmat.mat ] -> unit
   

 - val symm :
     side ->
       uplo ->
       alpha:float ->
       a:[< Gsl_vectmat.mat ] ->
       b:[< Gsl_vectmat.mat ] -> beta:float -> c:[< Gsl_vectmat.mat ] -> unit
   

 - val trmm :
     side ->
       uplo ->
       transpose ->
       diag ->
       alpha:float -> a:[< Gsl_vectmat.mat ] -> b:[< Gsl_vectmat.mat ] -> unit
   

 - val trsm :
     side ->
       uplo ->
       transpose ->
       diag ->
       alpha:float -> a:[< Gsl_vectmat.mat ] -> b:[< Gsl_vectmat.mat ] -> unit
   

 - val syrk :
     uplo ->
       transpose ->
       alpha:float ->
       a:[< Gsl_vectmat.mat ] -> beta:float -> c:[< Gsl_vectmat.mat ] -> unit
   

 - val syr2k :
     uplo ->
       transpose ->
       alpha:float ->
       a:[< Gsl_vectmat.mat ] ->
       b:[< Gsl_vectmat.mat ] -> beta:float -> c:[< Gsl_vectmat.mat ] -> unit
   

 - module Complex
   *Note Module Complex: Gsl_blas_gen/Complex.


File: gsl-ocaml.info,  Node: Gsl_blas_gen/Complex,  Up: Gsl_blas_gen

16.2 Module `Gsl_blas_gen.Complex'
==================================

16.2.1 Interface
----------------


 - val dotu :
     [< Gsl_vectmat.cvec ] -> [< Gsl_vectmat.cvec ] -> Gsl_complex.complex


 - val dotc :
     [< Gsl_vectmat.cvec ] -> [< Gsl_vectmat.cvec ] -> Gsl_complex.complex
   

 - val nrm2 :
     [< Gsl_vectmat.cvec ] -> float
   

 - val asum :
     [< Gsl_vectmat.cvec ] -> float
   

 - val iamax :
     [< Gsl_vectmat.cvec ] -> int
   

 - val swap :
     [< Gsl_vectmat.cvec ] -> [< Gsl_vectmat.cvec ] -> unit
   

 - val copy :
     [< Gsl_vectmat.cvec ] -> [< Gsl_vectmat.cvec ] -> unit
   

 - val axpy :
     Gsl_complex.complex -> [< Gsl_vectmat.cvec ] -> [< Gsl_vectmat.cvec ] -> unit
   

 - val scal :
     Gsl_complex.complex -> [< Gsl_vectmat.cvec ] -> unit
   

 - val zdscal :
     float -> [< Gsl_vectmat.cvec ] -> unit
   

 - val gemv :
     Gsl_blas_gen.transpose ->
       alpha:Gsl_complex.complex ->
       a:[< Gsl_vectmat.cmat ] ->
       x:[< Gsl_vectmat.cvec ] ->
       beta:Gsl_complex.complex -> y:[< Gsl_vectmat.cvec ] -> unit
   

 - val trmv :
     Gsl_blas_gen.uplo ->
       Gsl_blas_gen.transpose ->
       Gsl_blas_gen.diag ->
       a:[< Gsl_vectmat.cmat ] -> x:[< Gsl_vectmat.cvec ] -> unit
   

 - val trsv :
     Gsl_blas_gen.uplo ->
       Gsl_blas_gen.transpose ->
       Gsl_blas_gen.diag ->
       a:[< Gsl_vectmat.cmat ] -> x:[< Gsl_vectmat.cvec ] -> unit
   

 - val hemv :
     Gsl_blas_gen.uplo ->
       alpha:Gsl_complex.complex ->
       a:[< Gsl_vectmat.cmat ] ->
       x:[< Gsl_vectmat.cvec ] ->
       beta:Gsl_complex.complex -> y:[< Gsl_vectmat.cvec ] -> unit
   

 - val geru :
     alpha:Gsl_complex.complex ->
       x:[< Gsl_vectmat.cvec ] ->
       y:[< Gsl_vectmat.cvec ] -> a:[< Gsl_vectmat.cmat ] -> unit
   

 - val gerc :
     alpha:Gsl_complex.complex ->
       x:[< Gsl_vectmat.cvec ] ->
       y:[< Gsl_vectmat.cvec ] -> a:[< Gsl_vectmat.cmat ] -> unit
   

 - val her :
     Gsl_blas_gen.uplo ->
       alpha:float -> x:[< Gsl_vectmat.cvec ] -> a:[< Gsl_vectmat.cmat ] -> unit
   

 - val her2 :
     Gsl_blas_gen.uplo ->
       alpha:Gsl_complex.complex ->
       x:[< Gsl_vectmat.cvec ] ->
       y:[< Gsl_vectmat.cvec ] -> a:[< Gsl_vectmat.cmat ] -> unit
   

 - val gemm :
     ta:Gsl_blas_gen.transpose ->
       tb:Gsl_blas_gen.transpose ->
       alpha:Gsl_complex.complex ->
       a:[< Gsl_vectmat.cmat ] ->
       b:[< Gsl_vectmat.cmat ] ->
       beta:Gsl_complex.complex -> c:[< Gsl_vectmat.cmat ] -> unit
   

 - val symm :
     Gsl_blas_gen.side ->
       Gsl_blas_gen.uplo ->
       alpha:Gsl_complex.complex ->
       a:[< Gsl_vectmat.cmat ] ->
       b:[< Gsl_vectmat.cmat ] ->
       beta:Gsl_complex.complex -> c:[< Gsl_vectmat.cmat ] -> unit
   

 - val syrk :
     Gsl_blas_gen.uplo ->
       Gsl_blas_gen.transpose ->
       alpha:Gsl_complex.complex ->
       a:[< Gsl_vectmat.cmat ] ->
       beta:Gsl_complex.complex -> c:[< Gsl_vectmat.cmat ] -> unit
   

 - val syr2k :
     Gsl_blas_gen.uplo ->
       Gsl_blas_gen.transpose ->
       alpha:Gsl_complex.complex ->
       a:[< Gsl_vectmat.cmat ] ->
       b:[< Gsl_vectmat.cmat ] ->
       beta:Gsl_complex.complex -> c:[< Gsl_vectmat.cmat ] -> unit
   

 - val trmm :
     Gsl_blas_gen.side ->
       Gsl_blas_gen.uplo ->
       Gsl_blas_gen.transpose ->
       Gsl_blas_gen.diag ->
       alpha:Gsl_complex.complex ->
       a:[< Gsl_vectmat.cmat ] -> b:[< Gsl_vectmat.cmat ] -> unit
   

 - val trsm :
     Gsl_blas_gen.side ->
       Gsl_blas_gen.uplo ->
       Gsl_blas_gen.transpose ->
       Gsl_blas_gen.diag ->
       alpha:Gsl_complex.complex ->
       a:[< Gsl_vectmat.cmat ] -> b:[< Gsl_vectmat.cmat ] -> unit
   

 - val hemm :
     Gsl_blas_gen.side ->
       Gsl_blas_gen.uplo ->
       alpha:Gsl_complex.complex ->
       a:[< Gsl_vectmat.cmat ] ->
       b:[< Gsl_vectmat.cmat ] ->
       beta:Gsl_complex.complex -> c:[< Gsl_vectmat.cmat ] -> unit
   

 - val herk :
     Gsl_blas_gen.uplo ->
       Gsl_blas_gen.transpose ->
       alpha:float ->
       a:[< Gsl_vectmat.cmat ] -> beta:float -> c:[< Gsl_vectmat.cmat ] -> unit
   

 - val her2k :
     Gsl_blas_gen.uplo ->
       Gsl_blas_gen.transpose ->
       alpha:Gsl_complex.complex ->
       a:[< Gsl_vectmat.cmat ] ->
       b:[< Gsl_vectmat.cmat ] -> beta:float -> c:[< Gsl_vectmat.cmat ] -> unit
   

File: gsl-ocaml.info,  Node: Gsl_fun,  Next: Gsl_permut,  Prev: Gsl_blas_gen,  Up: Top

17 Module `Gsl_fun'
*******************

17.1 Description
================

Callbacks and types for error estimates

17.2 Interface
==============

17.2.1 Types for special functions
----------------------------------

These type are used by module *Note Module Gsl_sf: Gsl_sf.

 - type result = {
  res : float ;
  err : float ;
 }
   
   The result of a computation : `res' is the value and `err' an
estimate of the absolute  error in the value.


 - type result_e10 = {
  res_e10 : float ;
  err_e10 : float ;
  e10 : int ;
 }
   
   Result of computation with a scaling exponent. Actual result is
obtained as `res *. 10. ** e10'.


 - type mode =
  | DOUBLE
     (* Double precision : 2 * 10^-16 *)
  | SIMPLE
     (* Single precision : 10^-7 *)
  | APPROX
     (* Approximate values : 5 * 10^-4 *)
   
   Reduce the accuracy of some evaluations to speed up computations.


 - val smash :
     result_e10 -> result
   
17.2.2 Callbacks
----------------


 - type gsl_fun = float -> float


 - type gsl_fun_fdf = {
  f : float -> float ;
  df : float -> float ;
  fdf : float -> float * float ;
 }
   

 - type monte_fun = float array -> float
   

 - type multi_fun = x:Gsl_vector.vector -> f:Gsl_vector.vector -> unit
   

 - type multi_fun_fdf = {
  multi_f : x:Gsl_vector.vector -> f:Gsl_vector.vector -> unit ;
  multi_df : x:Gsl_vector.vector -> j:Gsl_matrix.matrix -> unit ;
  multi_fdf : x:Gsl_vector.vector -> f:Gsl_vector.vector -> j:Gsl_matrix.matrix -> unit ;
 }
   

 - type multim_fun = x:Gsl_vector.vector -> float
   

 - type multim_fun_fdf = {
  multim_f : x:Gsl_vector.vector -> float ;
  multim_df : x:Gsl_vector.vector -> g:Gsl_vector.vector -> unit ;
  multim_fdf : x:Gsl_vector.vector -> g:Gsl_vector.vector -> float ;
 }
   

File: gsl-ocaml.info,  Node: Gsl_permut,  Next: Gsl_sort,  Prev: Gsl_fun,  Up: Top

18 Module `Gsl_permut'
**********************

18.1 Description
================

Permutations

18.2 Interface
==============


 - type permut = (int, Bigarray.int_elt, Bigarray.c_layout) Bigarray.Array1.t


 - val of_array :
     int array -> permut
   

 - val to_array :
     permut -> int array
   

 - val init :
     permut -> unit
   

 - val create :
     int -> permut
   

 - val make :
     int -> permut
   

 - val swap :
     permut -> int -> int -> unit
   

 - val size :
     permut -> int
   

 - val valid :
     permut -> bool
   

 - val reverse :
     permut -> unit
   

 - val inverse :
     permut -> permut
   

 - val next :
     permut -> unit
   

 - val prev :
     permut -> unit
   

 - val permute :
     permut -> 'a array -> unit
   

 - val permute_barr :
     permut -> ('a, 'b, 'c) Bigarray.Array1.t -> unit
   

 - val permute_inverse :
     permut -> 'a array -> unit
   

 - val permute_inverse_barr :
     permut -> ('a, 'b, 'c) Bigarray.Array1.t -> unit
   

File: gsl-ocaml.info,  Node: Gsl_sort,  Next: Gsl_linalg,  Prev: Gsl_permut,  Up: Top

19 Module `Gsl_sort'
********************

19.1 Description
================

Sorting

19.2 Interface
==============


 - val vector :
     Gsl_vector.vector -> unit


 - val vector_index :
     Gsl_vector.vector -> Gsl_permut.permut
   

 - val vector_smallest :
     int -> Gsl_vector.vector -> float array
   

 - val vector_largest :
     int -> Gsl_vector.vector -> float array
   

 - val vector_smallest_index :
     int -> Gsl_vector.vector -> Gsl_permut.permut
   

 - val vector_largest_index :
     int -> Gsl_vector.vector -> Gsl_permut.permut
   

 - val vector_flat :
     Gsl_vector_flat.vector -> unit
   

 - val vector_flat_index :
     Gsl_vector_flat.vector -> Gsl_permut.permut
   

 - val vector_flat_smallest :
     int -> Gsl_vector_flat.vector -> float array
   

 - val vector_flat_largest :
     int -> Gsl_vector_flat.vector -> float array
   

 - val vector_flat_smallest_index :
     int -> Gsl_vector_flat.vector -> Gsl_permut.permut
   

 - val vector_flat_largest_index :
     int -> Gsl_vector_flat.vector -> Gsl_permut.permut
   

File: gsl-ocaml.info,  Node: Gsl_linalg,  Next: Gsl_eigen,  Prev: Gsl_sort,  Up: Top

20 Module `Gsl_linalg'
**********************

20.1 Description
================

Simple linear algebra operations

20.2 Interface
==============

20.2.1 Simple matrix multiplication
-----------------------------------


 - val matmult :
     a:Gsl_vectmat.mat ->
       ?transpa:bool ->
       b:Gsl_vectmat.mat -> ?transpb:bool -> Gsl_vectmat.mat -> unit

   `matmult a ~transpa b ~transpb c' stores in matrix `c' the product
of matrices `a' and `b'. `transpa' or `transpb' allow transposition of
either matrix, so it can compute a.b or Trans(a).b or a.Trans(b) or
Trans(a).Trans(b) .

   See also Gsl_blas.gemm.

20.2.2 LU decomposition
-----------------------

20.2.2.1 Low-level functions
............................


 - val _LU_decomp :
     Gsl_vectmat.mat -> Gsl_permut.permut -> int


 - val _LU_solve :
     Gsl_vectmat.mat ->
       Gsl_permut.permut -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   

 - val _LU_svx :
     Gsl_vectmat.mat -> Gsl_permut.permut -> Gsl_vectmat.vec -> unit
   

 - val _LU_refine :
     a:Gsl_vectmat.mat ->
       lu:Gsl_vectmat.mat ->
       Gsl_permut.permut ->
       b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> res:Gsl_vectmat.vec -> unit
   

 - val _LU_invert :
     Gsl_vectmat.mat -> Gsl_permut.permut -> Gsl_vectmat.mat -> unit
   

 - val _LU_det :
     Gsl_vectmat.mat -> int -> float
   

 - val _LU_lndet :
     Gsl_vectmat.mat -> float
   

 - val _LU_sgndet :
     Gsl_vectmat.mat -> int -> int
   
20.2.2.2 Higher-level functions
...............................

With these, the arguments are protected (copied) and necessary
intermediate datastructures are allocated;

 - val decomp_LU :
     ?protect:bool ->
       [< `A of float array * int * int
        | `AA of float array array
        | `M of Gsl_matrix.matrix
        | `MF of Gsl_matrix_flat.matrix ] ->
       Gsl_vectmat.mat * Gsl_permut.permut * int
   

 - val solve_LU :
     ?protect:bool ->
       [< `A of float array * int * int
        | `AA of float array array
        | `M of Gsl_matrix.matrix
        | `MF of Gsl_matrix_flat.matrix ] ->
       [< `A of float array
        | `V of Gsl_vector.vector
        | `VF of Gsl_vector_flat.vector ] ->
       float array
   

 - val det_LU :
     ?protect:bool ->
       [< `A of float array * int * int
        | `AA of float array array
        | `M of Gsl_matrix.matrix
        | `MF of Gsl_matrix_flat.matrix ] ->
       float
   

 - val invert_LU :
     ?protect:bool ->
       ?result:Gsl_vectmat.mat ->
       [< `A of float array * int * int
        | `AA of float array array
        | `M of Gsl_matrix.matrix
        | `MF of Gsl_matrix_flat.matrix ] ->
       Gsl_vectmat.mat
   
20.2.3 Complex LU decomposition
-------------------------------


 - val complex_LU_decomp :
     Gsl_vectmat.cmat -> Gsl_permut.permut -> int


 - val complex_LU_solve :
     Gsl_vectmat.cmat ->
       Gsl_permut.permut -> b:Gsl_vectmat.cvec -> x:Gsl_vectmat.cvec -> unit
   

 - val complex_LU_svx :
     Gsl_vectmat.cmat -> Gsl_permut.permut -> Gsl_vectmat.cvec -> unit
   

 - val complex_LU_refine :
     a:Gsl_vectmat.cmat ->
       lu:Gsl_vectmat.cmat ->
       Gsl_permut.permut ->
       b:Gsl_vectmat.cvec -> x:Gsl_vectmat.cvec -> res:Gsl_vectmat.cvec -> unit
   

 - val complex_LU_invert :
     Gsl_vectmat.cmat -> Gsl_permut.permut -> Gsl_vectmat.cmat -> unit
   

 - val complex_LU_det :
     Gsl_vectmat.cmat -> int -> Gsl_complex.complex
   

 - val complex_LU_lndet :
     Gsl_vectmat.cmat -> float
   

 - val complex_LU_sgndet :
     Gsl_vectmat.cmat -> int -> Gsl_complex.complex
   
20.2.4 QR decomposition
-----------------------


 - val _QR_decomp :
     Gsl_vectmat.mat -> Gsl_vectmat.vec -> unit


 - val _QR_solve :
     Gsl_vectmat.mat ->
       Gsl_vectmat.vec -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   

 - val _QR_svx :
     Gsl_vectmat.mat -> Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   

 - val _QR_lssolve :
     Gsl_vectmat.mat ->
       Gsl_vectmat.vec ->
       b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> res:Gsl_vectmat.vec -> unit
   

 - val _QR_QTvec :
     Gsl_vectmat.mat -> Gsl_vectmat.vec -> v:Gsl_vectmat.vec -> unit
   

 - val _QR_Qvec :
     Gsl_vectmat.mat -> Gsl_vectmat.vec -> v:Gsl_vectmat.vec -> unit
   

 - val _QR_Rsolve :
     Gsl_vectmat.mat -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   

 - val _QR_Rsvx :
     Gsl_vectmat.mat -> x:Gsl_vectmat.vec -> unit
   

 - val _QR_unpack :
     Gsl_vectmat.mat ->
       tau:Gsl_vectmat.vec -> q:Gsl_vectmat.mat -> r:Gsl_vectmat.mat -> unit
   

 - val _QR_QRsolve :
     Gsl_vectmat.mat ->
       r:Gsl_vectmat.mat -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   

 - val _QR_update :
     Gsl_vectmat.mat ->
       r:Gsl_vectmat.mat -> w:Gsl_vectmat.vec -> v:Gsl_vectmat.vec -> unit
   

 - val _R_solve :
     r:Gsl_vectmat.mat -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   
20.2.5 QR Decomposition with Column Pivoting
--------------------------------------------


 - val _QRPT_decomp :
     a:Gsl_vectmat.mat ->
       tau:Gsl_vectmat.vec -> p:Gsl_permut.permut -> norm:Gsl_vectmat.vec -> int


 - val _QRPT_decomp2 :
     a:Gsl_vectmat.mat ->
       q:Gsl_vectmat.mat ->
       r:Gsl_vectmat.mat ->
       tau:Gsl_vectmat.vec -> p:Gsl_permut.permut -> norm:Gsl_vectmat.vec -> int
   

 - val _QRPT_solve :
     qr:Gsl_vectmat.mat ->
       tau:Gsl_vectmat.vec ->
       p:Gsl_permut.permut -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   

 - val _QRPT_svx :
     qr:Gsl_vectmat.mat ->
       tau:Gsl_vectmat.vec -> p:Gsl_permut.permut -> x:Gsl_vectmat.vec -> unit
   

 - val _QRPT_QRsolve :
     q:Gsl_vectmat.mat ->
       r:Gsl_vectmat.mat ->
       p:Gsl_permut.permut -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   

 - val _QRPT_update :
     q:Gsl_vectmat.mat ->
       r:Gsl_vectmat.mat ->
       p:Gsl_permut.permut -> u:Gsl_vectmat.vec -> v:Gsl_vectmat.vec -> unit
   

 - val _QRPT_Rsolve :
     qr:Gsl_vectmat.mat ->
       p:Gsl_permut.permut -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   

 - val _QRPT_Rsvx :
     qr:Gsl_vectmat.mat -> p:Gsl_permut.permut -> x:Gsl_vectmat.vec -> unit
   
20.2.6 Singular Value Decomposition
-----------------------------------


 - val _SV_decomp :
     a:Gsl_vectmat.mat ->
       v:Gsl_vectmat.mat -> s:Gsl_vectmat.vec -> work:Gsl_vectmat.vec -> unit


 - val _SV_decomp_mod :
     a:Gsl_vectmat.mat ->
       x:Gsl_vectmat.mat ->
       v:Gsl_vectmat.mat -> s:Gsl_vectmat.vec -> work:Gsl_vectmat.vec -> unit
   

 - val _SV_decomp_jacobi :
     a:Gsl_vectmat.mat -> v:Gsl_vectmat.mat -> s:Gsl_vectmat.vec -> unit
   

 - val _SV_solve :
     u:Gsl_vectmat.mat ->
       v:Gsl_vectmat.mat ->
       s:Gsl_vectmat.vec -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   
20.2.7 LQ decomposition
-----------------------


 - val _LQ_decomp :
     a:Gsl_vectmat.mat -> tau:Gsl_vectmat.vec -> unit


 - val _LQ_solve_T :
     lq:Gsl_vectmat.mat ->
       tau:Gsl_vectmat.vec -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   

 - val _LQ_svx_T :
     lq:Gsl_vectmat.mat -> tau:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   

 - val _LQ_lssolve_T :
     lq:Gsl_vectmat.mat ->
       tau:Gsl_vectmat.vec ->
       b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> res:Gsl_vectmat.vec -> unit
   

 - val _LQ_Lsolve_T :
     lq:Gsl_vectmat.mat -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   

 - val _LQ_Lsvx_T :
     lq:Gsl_vectmat.mat -> x:Gsl_vectmat.vec -> unit
   

 - val _L_solve_T :
     l:Gsl_vectmat.mat -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   

 - val _LQ_vecQ :
     lq:Gsl_vectmat.mat -> tau:Gsl_vectmat.vec -> v:Gsl_vectmat.vec -> unit
   

 - val _LQ_vecQT :
     lq:Gsl_vectmat.mat -> tau:Gsl_vectmat.vec -> v:Gsl_vectmat.vec -> unit
   

 - val _LQ_unpack :
     lq:Gsl_vectmat.mat ->
       tau:Gsl_vectmat.vec -> q:Gsl_vectmat.mat -> l:Gsl_vectmat.mat -> unit
   

 - val _LQ_update :
     q:Gsl_vectmat.mat ->
       r:Gsl_vectmat.mat -> v:Gsl_vectmat.vec -> w:Gsl_vectmat.vec -> unit
   

 - val _LQ_LQsolve :
     q:Gsl_vectmat.mat ->
       l:Gsl_vectmat.mat -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   
20.2.8 P^T L Q decomposition
----------------------------


 - val _PTLQ_decomp :
     a:Gsl_vectmat.mat ->
       tau:Gsl_vectmat.vec -> Gsl_permut.permut -> norm:Gsl_vectmat.vec -> int


 - val _PTLQ_decomp2 :
     a:Gsl_vectmat.mat ->
       q:Gsl_vectmat.mat ->
       r:Gsl_vectmat.mat ->
       tau:Gsl_vectmat.vec -> Gsl_permut.permut -> norm:Gsl_vectmat.vec -> int
   

 - val _PTLQ_solve_T :
     qr:Gsl_vectmat.mat ->
       tau:Gsl_vectmat.vec ->
       Gsl_permut.permut -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   

 - val _PTLQ_svx_T :
     lq:Gsl_vectmat.mat ->
       tau:Gsl_vectmat.vec -> Gsl_permut.permut -> x:Gsl_vectmat.vec -> unit
   

 - val _PTLQ_LQsolve_T :
     q:Gsl_vectmat.mat ->
       l:Gsl_vectmat.mat ->
       Gsl_permut.permut -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   

 - val _PTLQ_Lsolve_T :
     lq:Gsl_vectmat.mat ->
       Gsl_permut.permut -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   

 - val _PTLQ_Lsvx_T :
     lq:Gsl_vectmat.mat -> Gsl_permut.permut -> x:Gsl_vectmat.vec -> unit
   

 - val _PTLQ_update :
     q:Gsl_vectmat.mat ->
       l:Gsl_vectmat.mat ->
       Gsl_permut.permut -> v:Gsl_vectmat.vec -> w:Gsl_vectmat.vec -> unit
   
20.2.9 Cholesky decomposition
-----------------------------


 - val cho_decomp :
     Gsl_vectmat.mat -> unit


 - val cho_solve :
     Gsl_vectmat.mat -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   

 - val cho_svx :
     Gsl_vectmat.mat -> Gsl_vectmat.vec -> unit
   

 - val cho_decomp_unit :
     Gsl_vectmat.mat -> Gsl_vectmat.vec -> unit
   
20.2.10 Tridiagonal Decomposition of Real Symmetric Matrices
------------------------------------------------------------


 - val symmtd_decomp :
     a:Gsl_vectmat.mat -> tau:Gsl_vectmat.vec -> unit


 - val symmtd_unpack :
     a:Gsl_vectmat.mat ->
       tau:Gsl_vectmat.vec ->
       q:Gsl_vectmat.mat -> diag:Gsl_vectmat.vec -> subdiag:Gsl_vectmat.vec -> unit
   

 - val symmtd_unpack_T :
     a:Gsl_vectmat.mat -> diag:Gsl_vectmat.vec -> subdiag:Gsl_vectmat.vec -> unit
   
20.2.11 Tridiagonal Decomposition of Hermitian Matrices
-------------------------------------------------------


 - val hermtd_decomp :
     a:Gsl_vectmat.cmat -> tau:Gsl_vectmat.cvec -> unit


 - val hermtd_unpack :
     a:Gsl_vectmat.cmat ->
       tau:Gsl_vectmat.cvec ->
       q:Gsl_vectmat.cmat -> diag:Gsl_vectmat.vec -> subdiag:Gsl_vectmat.vec -> unit
   

 - val hermtd_unpack_T :
     a:Gsl_vectmat.cmat -> diag:Gsl_vectmat.vec -> subdiag:Gsl_vectmat.vec -> unit
   
20.2.12 Bidiagonalization
-------------------------


 - val bidiag_decomp :
     a:Gsl_vectmat.mat -> tau_u:Gsl_vectmat.vec -> tau_v:Gsl_vectmat.vec -> unit


 - val bidiag_unpack :
     a:Gsl_vectmat.mat ->
       tau_u:Gsl_vectmat.vec ->
       u:Gsl_vectmat.mat ->
       tau_v:Gsl_vectmat.vec ->
       v:Gsl_vectmat.mat ->
       diag:Gsl_vectmat.vec -> superdiag:Gsl_vectmat.vec -> unit
   

 - val bidiag_unpack2 :
     a:Gsl_vectmat.mat ->
       tau_u:Gsl_vectmat.vec -> tau_v:Gsl_vectmat.vec -> v:Gsl_vectmat.mat -> unit
   

 - val bidiag_unpack_B :
     a:Gsl_vectmat.mat ->
       diag:Gsl_vectmat.vec -> superdiag:Gsl_vectmat.vec -> unit
   
20.2.13 Householder solver
--------------------------


 - val _HH_solve :
     Gsl_vectmat.mat -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit


 - val _HH_svx :
     Gsl_vectmat.mat -> Gsl_vectmat.vec -> unit
   

 - val solve_HH :
     ?protect:bool ->
       [< `A of float array * int * int
        | `AA of float array array
        | `M of Gsl_matrix.matrix
        | `MF of Gsl_matrix_flat.matrix ] ->
       [< `A of float array
        | `V of Gsl_vector.vector
        | `VF of Gsl_vector_flat.vector ] ->
       float array
   
20.2.14 Tridiagonal Systems
---------------------------


 - val solve_symm_tridiag :
     diag:Gsl_vectmat.vec ->
       offdiag:Gsl_vectmat.vec -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit


 - val solve_tridiag :
     diag:Gsl_vectmat.vec ->
       abovediag:Gsl_vectmat.vec ->
       belowdiag:Gsl_vectmat.vec -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   

 - val solve_symm_cyc_tridiag :
     diag:Gsl_vectmat.vec ->
       offdiag:Gsl_vectmat.vec -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   

 - val solve_cyc_tridiag :
     diag:Gsl_vectmat.vec ->
       abovediag:Gsl_vectmat.vec ->
       belowdiag:Gsl_vectmat.vec -> b:Gsl_vectmat.vec -> x:Gsl_vectmat.vec -> unit
   
20.2.15 Exponential
-------------------


 - val _exponential :
     Gsl_vectmat.mat -> Gsl_vectmat.mat -> Gsl_fun.mode -> unit


 - val exponential :
     ?mode:Gsl_fun.mode ->
       [< `A of float array * int * int
        | `M of Gsl_matrix.matrix
        | `MF of Gsl_matrix_flat.matrix ] ->
       [ `M of Gsl_matrix.matrix ]
   

File: gsl-ocaml.info,  Node: Gsl_eigen,  Next: Gsl_poly,  Prev: Gsl_linalg,  Up: Top

21 Module `Gsl_eigen'
*********************

21.1 Description
================

Eigensystems

21.2 Interface
==============

21.2.1 Real Symmetric Matrices
------------------------------


 - type symm_ws


 - val make_symm_ws :
     int -> symm_ws
   

 - val _symm :
     Gsl_vectmat.mat -> Gsl_vectmat.vec -> symm_ws -> unit
   

 - val symm :
     ?protect:bool ->
       [< `A of float array * int * int
        | `AA of float array array
        | `M of Gsl_matrix.matrix
        | `MF of Gsl_matrix_flat.matrix ] ->
       Gsl_vector.vector
   

 - type symmv_ws
   

 - val make_symmv_ws :
     int -> symmv_ws
   

 - val _symmv :
     Gsl_vectmat.mat ->
       Gsl_vectmat.vec -> Gsl_vectmat.mat -> symmv_ws -> unit
   

 - val symmv :
     ?protect:bool ->
       [< `A of float array * int * int
        | `AA of float array array
        | `M of Gsl_matrix.matrix
        | `MF of Gsl_matrix_flat.matrix ] ->
       Gsl_vector.vector * Gsl_matrix.matrix
   

 - type sort =
  | VAL_ASC
  | VAL_DESC
  | ABS_ASC
  | ABS_DESC
   

 - val symmv_sort :
     Gsl_vector.vector * Gsl_matrix.matrix -> sort -> unit
   
21.2.2 Complex Hermitian Matrices
---------------------------------


 - type herm_ws


 - val make_herm_ws :
     int -> herm_ws
   

 - val _herm :
     Gsl_vectmat.cmat -> Gsl_vectmat.vec -> herm_ws -> unit
   

 - val herm :
     ?protect:bool ->
       [< `CA of Gsl_complex.complex_array * int * int
        | `CM of Gsl_matrix_complex.matrix
        | `CMF of Gsl_matrix_complex_flat.matrix ] ->
       Gsl_vector.vector
   

 - type hermv_ws
   

 - val make_hermv_ws :
     int -> hermv_ws
   

 - val _hermv :
     Gsl_vectmat.cmat ->
       Gsl_vectmat.vec -> Gsl_vectmat.cmat -> hermv_ws -> unit
   

 - val hermv :
     ?protect:bool ->
       [< `CA of Gsl_complex.complex_array * int * int
        | `CM of Gsl_matrix_complex.matrix
        | `CMF of Gsl_matrix_complex_flat.matrix ] ->
       Gsl_vector.vector * Gsl_matrix_complex.matrix
   

 - val hermv_sort :
     Gsl_vector.vector * Gsl_matrix_complex.matrix -> sort -> unit
   
21.2.3 Real Nonsymmetric Matrices
---------------------------------


 - type nonsymm_ws


 - val make_nonsymm_ws :
     int -> nonsymm_ws
   

 - val _nonsymm :
     Gsl_vectmat.mat -> Gsl_vectmat.cvec -> nonsymm_ws -> unit
   

 - val _nonsymm_Z :
     Gsl_vectmat.mat ->
       Gsl_vectmat.cvec -> Gsl_vectmat.mat -> nonsymm_ws -> unit
   

 - val nonsymm :
     ?protect:bool ->
       [< `A of float array * int * int
        | `AA of float array array
        | `M of Gsl_matrix.matrix
        | `MF of Gsl_matrix_flat.matrix ] ->
       Gsl_vector_complex.vector
   

 - type nonsymmv_ws
   

 - val make_nonsymmv_ws :
     int -> nonsymmv_ws
   

 - val _nonsymmv :
     Gsl_vectmat.mat ->
       Gsl_vectmat.cvec -> Gsl_vectmat.cmat -> nonsymmv_ws -> unit
   

 - val _nonsymmv_Z :
     Gsl_vectmat.mat ->
       Gsl_vectmat.cvec ->
       Gsl_vectmat.cmat -> Gsl_vectmat.mat -> nonsymmv_ws -> unit
   

 - val nonsymmv :
     ?protect:bool ->
       [< `A of float array * int * int
        | `AA of float array array
        | `M of Gsl_matrix.matrix
        | `MF of Gsl_matrix_flat.matrix ] ->
       Gsl_vector_complex.vector * Gsl_matrix_complex.matrix
   

 - val nonsymmv_sort :
     Gsl_vector_complex.vector * Gsl_matrix_complex.matrix ->
       sort -> unit
   

File: gsl-ocaml.info,  Node: Gsl_poly,  Next: Gsl_interp,  Prev: Gsl_eigen,  Up: Top

22 Module `Gsl_poly'
********************

22.1 Description
================

Polynomials

22.2 Interface
==============


 - type poly = float array

22.2.1 Polynomial Evaluation
----------------------------


 - val eval :
     poly -> float -> float

22.2.2 Quadratic Equations
--------------------------


 - type quad_sol =
  | Quad_0
  | Quad_2 of (float * float)


 - val solve_quadratic :
     a:float -> b:float -> c:float -> quad_sol
   

 - val complex_solve_quadratic :
     a:float -> b:float -> c:float -> Gsl_complex.complex * Gsl_complex.complex
   
22.2.3 Cubic Equations
----------------------


 - type cubic_sol =
  | Cubic_0
  | Cubic_1 of float
  | Cubic_3 of (float * float * float)


 - val solve_cubic :
     a:float -> b:float -> c:float -> cubic_sol
   

 - val complex_solve_cubic :
     a:float ->
       b:float ->
       c:float -> Gsl_complex.complex * Gsl_complex.complex * Gsl_complex.complex
   
22.2.4 General Polynomial Equations
-----------------------------------


 - val solve :
     poly -> Gsl_complex.complex_array


File: gsl-ocaml.info,  Node: Gsl_interp,  Next: Gsl_rng,  Prev: Gsl_poly,  Up: Top

23 Module `Gsl_interp'
**********************

23.1 Description
================

Interpolation

23.2 Interface
==============


 - type t


 - type accel
   

 - type interp_type =
  | LINEAR
  | POLYNOMIAL
  | CSPLINE
  | CSPLINE_PERIODIC
  | AKIMA
  | AKIMA_PERIODIC
   

 - val make :
     interp_type -> int -> t
   

 - val init :
     t -> float array -> float array -> unit
   

 - val name :
     t -> string
   

 - val min_size :
     t -> int
   

 - val make_accel :
     unit -> accel
   

 - val i_eval :
     t ->
       float array -> float array -> float -> accel -> float
   

 - val i_eval_deriv :
     t ->
       float array -> float array -> float -> accel -> float
   

 - val i_eval_deriv2 :
     t ->
       float array -> float array -> float -> accel -> float
   

 - val i_eval_integ :
     t ->
       float array -> float array -> float -> float -> accel -> float
   
23.2.1 Higher level functions
-----------------------------


 - type interp = {
  interp : Gsl_interp.t ;
  accel : Gsl_interp.accel ;
  xa : float array ;
  ya : float array ;
  size : int ;
  i_type : Gsl_interp.interp_type ;
 }


 - val make_interp :
     interp_type -> float array -> float array -> interp
   

 - val eval :
     interp -> float -> float
   

 - val eval_array :
     interp -> float array -> float array -> unit
   
   `eval_array interp x_a y_a' fills the array `y_a' with the
evaluation of the interpolation function `interp' for each point of
array `x_a'. `x_a' and `y_a' must have the same length.


 - val eval_deriv :
     interp -> float -> float
   

 - val eval_deriv2 :
     interp -> float -> float
   

 - val eval_integ :
     interp -> float -> float -> float
   

File: gsl-ocaml.info,  Node: Gsl_rng,  Next: Gsl_qrng,  Prev: Gsl_interp,  Up: Top

24 Module `Gsl_rng'
*******************

24.1 Description
================

Random Number Generation

24.2 Interface
==============


 - type rng_type =
  | BOROSH13
  | COVEYOU
  | CMRG
  | FISHMAN18
  | FISHMAN20
  | FISHMAN2X
  | GFSR4
  | KNUTHRAN
  | KNUTHRAN2
  | KNUTHRAN2002
  | LECUYER21
  | MINSTD
  | MRG
  | MT19937
  | MT19937_1999
  | MT19937_1998
  | R250
  | RAN0
  | RAN1
  | RAN2
  | RAN3
  | RAND
  | RAND48
  | RANDOM128_BSD
  | RANDOM128_GLIBC2
  | RANDOM128_LIBC5
  | RANDOM256_BSD
  | RANDOM256_GLIBC2
  | RANDOM256_LIBC5
  | RANDOM32_BSD
  | RANDOM32_GLIBC2
  | RANDOM32_LIBC5
  | RANDOM64_BSD
  | RANDOM64_GLIBC2
  | RANDOM64_LIBC5
  | RANDOM8_BSD
  | RANDOM8_GLIBC2
  | RANDOM8_LIBC5
  | RANDOM_BSD
  | RANDOM_GLIBC2
  | RANDOM_LIBC5
  | RANDU
  | RANF
  | RANLUX
  | RANLUX389
  | RANLXD1
  | RANLXD2
  | RANLXS0
  | RANLXS1
  | RANLXS2
  | RANMAR
  | SLATEC
  | TAUS
  | TAUS_2
  | TAUS_113
  | TRANSPUTER
  | TT800
  | UNI
  | UNI32
  | VAX
  | WATERMAN14
  | ZUF


 - type t
   
24.2.1 Default values
---------------------


 - val default :
     unit -> rng_type


 - val default_seed :
     unit -> nativeint
   

 - val set_default :
     rng_type -> unit
   

 - val set_default_seed :
     nativeint -> unit
   

 - val env_setup :
     unit -> unit
   
24.2.2 Creating
---------------


 - val make :
     rng_type -> t


 - val set :
     t -> nativeint -> unit
   

 - val name :
     t -> string
   

 - val get_type :
     t -> rng_type
   
   warning : the nativeint used for seeds are in fact unsigned but
ocaml treats them as signed.     But you can still print them using %nu
with printf functions.

 - val max :
     t -> nativeint
   

 - val min :
     t -> nativeint
   

 - val memcpy :
     t -> t -> unit
   

 - val clone :
     t -> t
   

 - val dump_state :
     t -> string * string
   

 - val set_state :
     t -> string * string -> unit
   
24.2.3 Sampling
---------------


 - val get :
     t -> nativeint


 - val uniform :
     t -> float
   

 - val uniform_pos :
     t -> float
   

 - val uniform_int :
     t -> int -> int
   
   These function fill the array with random numbers :

 - val uniform_arr :
     t -> float array -> unit
   

 - val uniform_pos_arr :
     t -> float array -> unit
   

File: gsl-ocaml.info,  Node: Gsl_qrng,  Next: Gsl_randist,  Prev: Gsl_rng,  Up: Top

25 Module `Gsl_qrng'
********************

25.1 Description
================

Quasi-Random Sequences

25.2 Interface
==============


 - type qrng_type =
  | NIEDERREITER_2
  | SOBOL


 - type t
   

 - val make :
     qrng_type -> int -> t
   

 - val init :
     t -> unit
   

 - val get :
     t -> float array -> unit
   

 - val sample :
     t -> float array
   

 - val name :
     t -> string
   

 - val dimension :
     t -> int
   

 - val memcpy :
     src:t -> dst:t -> unit
   

 - val clone :
     t -> t
   

File: gsl-ocaml.info,  Node: Gsl_randist,  Next: Gsl_integration,  Prev: Gsl_qrng,  Up: Top

26 Module `Gsl_randist'
***********************

26.1 Description
================

Random Number Distributions

26.2 Interface
==============


 - val gaussian :
     Gsl_rng.t -> sigma:float -> float


 - val gaussian_ratio_method :
     Gsl_rng.t -> sigma:float -> float
   

 - val gaussian_ziggurat :
     Gsl_rng.t -> sigma:float -> float
   

 - val gaussian_pdf :
     float -> sigma:float -> float
   

 - val ugaussian :
     Gsl_rng.t -> float
   

 - val ugaussian_ratio_method :
     Gsl_rng.t -> float
   

 - val ugaussian_pdf :
     float -> float
   

 - val gaussian_tail :
     Gsl_rng.t -> a:float -> sigma:float -> float
   

 - val gaussian_tail_pdf :
     float -> a:float -> sigma:float -> float
   

 - val ugaussian_tail :
     Gsl_rng.t -> a:float -> float
   

 - val ugaussian_tail_pdf :
     float -> a:float -> float
   

 - val bivariate_gaussian :
     Gsl_rng.t -> sigma_x:float -> sigma_y:float -> rho:float -> float * float
   

 - val bivariate_gaussian_pdf :
     x:float -> y:float -> sigma_x:float -> sigma_y:float -> rho:float -> float
   

 - val exponential :
     Gsl_rng.t -> mu:float -> float
   

 - val exponential_pdf :
     float -> mu:float -> float
   

 - val laplace :
     Gsl_rng.t -> a:float -> float
   

 - val laplace_pdf :
     float -> a:float -> float
   

 - val exppow :
     Gsl_rng.t -> a:float -> b:float -> float
   

 - val exppow_pdf :
     float -> a:float -> b:float -> float
   

 - val cauchy :
     Gsl_rng.t -> a:float -> float
   

 - val cauchy_pdf :
     float -> a:float -> float
   

 - val rayleigh :
     Gsl_rng.t -> sigma:float -> float
   

 - val rayleigh_pdf :
     float -> sigma:float -> float
   

 - val rayleigh_tail :
     Gsl_rng.t -> a:float -> sigma:float -> float
   

 - val rayleigh_tail_pdf :
     float -> a:float -> sigma:float -> float
   

 - val landau :
     Gsl_rng.t -> float
   

 - val landau_pdf :
     float -> float
   

 - val levy :
     Gsl_rng.t -> c:float -> alpha:float -> float
   

 - val levy_skew :
     Gsl_rng.t -> c:float -> alpha:float -> beta:float -> float
   

 - val gamma :
     Gsl_rng.t -> a:float -> b:float -> float
   

 - val gamma_int :
     Gsl_rng.t -> a:int -> float
   

 - val gamma_pdf :
     float -> a:float -> b:float -> float
   

 - val gamma_mt :
     Gsl_rng.t -> a:int -> b:float -> float
   

 - val gamma_knuth :
     Gsl_rng.t -> a:int -> b:float -> float
   

 - val flat :
     Gsl_rng.t -> a:float -> b:float -> float
   

 - val flat_pdf :
     float -> a:float -> b:float -> float
   

 - val lognormal :
     Gsl_rng.t -> zeta:float -> sigma:float -> float
   

 - val lognormal_pdf :
     float -> zeta:float -> sigma:float -> float
   

 - val chisq :
     Gsl_rng.t -> nu:float -> float
   

 - val chisq_pdf :
     float -> nu:float -> float
   

 - val dirichlet :
     Gsl_rng.t -> alpha:float array -> theta:float array -> unit
   

 - val dirichlet_pdf :
     alpha:float array -> theta:float array -> float
   

 - val dirichlet_lnpdf :
     alpha:float array -> theta:float array -> float
   

 - val fdist :
     Gsl_rng.t -> nu1:float -> nu2:float -> float
   

 - val fdist_pdf :
     float -> nu1:float -> nu2:float -> float
   

 - val tdist :
     Gsl_rng.t -> nu:float -> float
   

 - val tdist_pdf :
     float -> nu:float -> float
   

 - val beta :
     Gsl_rng.t -> a:float -> b:float -> float
   

 - val beta_pdf :
     float -> a:float -> b:float -> float
   

 - val logistic :
     Gsl_rng.t -> a:float -> float
   

 - val logistic_pdf :
     float -> a:float -> float
   

 - val pareto :
     Gsl_rng.t -> a:float -> b:float -> float
   

 - val pareto_pdf :
     float -> a:float -> b:float -> float
   

 - val dir_2d :
     Gsl_rng.t -> float * float
   

 - val dir_2d_trig_method :
     Gsl_rng.t -> float * float
   

 - val dir_3d :
     Gsl_rng.t -> float * float * float
   

 - val dir_nd :
     Gsl_rng.t -> float array -> unit
   

 - val weibull :
     Gsl_rng.t -> a:float -> b:float -> float
   

 - val weibull_pdf :
     float -> a:float -> b:float -> float
   

 - val gumbel1 :
     Gsl_rng.t -> a:float -> b:float -> float
   

 - val gumbel1_pdf :
     float -> a:float -> b:float -> float
   

 - val gumbel2 :
     Gsl_rng.t -> a:float -> b:float -> float
   

 - val gumbel2_pdf :
     float -> a:float -> b:float -> float
   

 - type discrete
   

 - val discrete_preproc :
     float array -> discrete
   

 - val discrete :
     Gsl_rng.t -> discrete -> int
   

 - val discrete_pdf :
     int -> discrete -> float
   

 - val poisson :
     Gsl_rng.t -> mu:float -> int
   

 - val poisson_pdf :
     int -> mu:float -> float
   

 - val bernoulli :
     Gsl_rng.t -> p:float -> int
   

 - val bernoulli_pdf :
     int -> p:float -> float
   

 - val binomial :
     Gsl_rng.t -> p:float -> n:int -> int
   

 - val binomial_knuth :
     Gsl_rng.t -> p:float -> n:int -> int
   

 - val binomial_tpe :
     Gsl_rng.t -> p:float -> n:int -> int
   

 - val binomial_pdf :
     int -> p:float -> n:int -> float
   

 - val multinomial :
     Gsl_rng.t -> n:int -> p:float array -> int array
   

 - val multinomial_pdf :
     p:float array -> n:int array -> float
   

 - val multinomial_lnpdf :
     p:float array -> n:int array -> float
   

 - val negative_binomial :
     Gsl_rng.t -> p:float -> n:int -> int
   

 - val negative_binomial_pdf :
     int -> p:float -> n:int -> float
   

 - val pascal :
     Gsl_rng.t -> p:float -> k:int -> int
   

 - val pascal_pdf :
     int -> p:float -> n:int -> float
   

 - val geometric :
     Gsl_rng.t -> p:float -> int
   

 - val geometric_pdf :
     int -> p:float -> float
   

 - val hypergeometric :
     Gsl_rng.t -> n1:int -> n2:int -> t:int -> int
   

 - val hypergeometric_pdf :
     int -> n1:int -> n2:int -> t:int -> float
   

 - val logarithmic :
     Gsl_rng.t -> p:float -> int
   

 - val logarithmic_pdf :
     int -> p:float -> float
   

 - val shuffle :
     Gsl_rng.t -> 'a array -> unit
   

 - val choose :
     Gsl_rng.t -> src:'a array -> dst:'a array -> unit
   

 - val sample :
     Gsl_rng.t -> src:'a array -> dst:'a array -> unit
   

File: gsl-ocaml.info,  Node: Gsl_integration,  Next: Gsl_fit,  Prev: Gsl_randist,  Up: Top

27 Module `Gsl_integration'
***************************

27.1 Description
================

Numerical Integration

27.2 Interface
==============


 - val qng :
     Gsl_fun.gsl_fun ->
       a:float -> b:float -> epsabs:float -> epsrel:float -> float * float * int


 - type workspace
   

 - val make_ws :
     int -> workspace
   

 - val size :
     workspace -> int
   

 - type key =
  | GAUSS15
  | GAUSS21
  | GAUSS31
  | GAUSS41
  | GAUSS51
  | GAUSS61
   

 - val qag :
     Gsl_fun.gsl_fun ->
       a:float ->
       b:float ->
       epsabs:float ->
       epsrel:float ->
       ?limit:int ->
       key -> workspace -> Gsl_fun.result
   

 - val qags :
     Gsl_fun.gsl_fun ->
       a:float ->
       b:float ->
       epsabs:float ->
       epsrel:float -> ?limit:int -> workspace -> Gsl_fun.result
   

 - val qagp :
     Gsl_fun.gsl_fun ->
       pts:float array ->
       epsabs:float ->
       epsrel:float -> ?limit:int -> workspace -> Gsl_fun.result
   

 - val qagi :
     Gsl_fun.gsl_fun ->
       epsabs:float ->
       epsrel:float -> ?limit:int -> workspace -> Gsl_fun.result
   

 - val qagiu :
     Gsl_fun.gsl_fun ->
       a:float ->
       epsabs:float ->
       epsrel:float -> ?limit:int -> workspace -> Gsl_fun.result
   

 - val qagil :
     Gsl_fun.gsl_fun ->
       b:float ->
       epsabs:float ->
       epsrel:float -> ?limit:int -> workspace -> Gsl_fun.result
   

 - val qag_sing :
     Gsl_fun.gsl_fun ->
       a:float ->
       b:float ->
       ?pts:float array ->
       ?limit:int -> epsabs:float -> epsrel:float -> unit -> Gsl_fun.result
   

 - val qawc :
     Gsl_fun.gsl_fun ->
       a:float ->
       b:float ->
       c:float ->
       epsabs:float ->
       epsrel:float -> ?limit:int -> workspace -> Gsl_fun.result
   

 - type qaws_table
   

 - val alloc_qaws :
     alpha:float -> beta:float -> mu:int -> nu:int -> qaws_table
   

 - val set_qaws :
     qaws_table ->
       alpha:float -> beta:float -> mu:int -> nu:int -> unit
   

 - val free_qaws :
     qaws_table -> unit
   

 - val qaws :
     Gsl_fun.gsl_fun ->
       a:float ->
       b:float ->
       qaws_table ->
       epsabs:float ->
       epsrel:float -> ?limit:int -> workspace -> Gsl_fun.result
   

 - type qawo_table
   

 - type qawo_sine =
  | QAWO_COSINE
  | QAWO_SINE
   

 - val alloc_qawo :
     omega:float ->
       l:float -> qawo_sine -> n:int -> qawo_table
   

 - val set_qawo :
     qawo_table ->
       omega:float -> l:float -> qawo_sine -> unit
   

 - val free_qawo :
     qawo_table -> unit
   

 - val qawo :
     Gsl_fun.gsl_fun ->
       a:float ->
       epsabs:float ->
       epsrel:float ->
       ?limit:int ->
       workspace -> qawo_table -> Gsl_fun.result
   

 - val qawf :
     Gsl_fun.gsl_fun ->
       a:float ->
       epsabs:float ->
       ?limit:int ->
       workspace ->
       workspace -> qawo_table -> Gsl_fun.result
   

File: gsl-ocaml.info,  Node: Gsl_fit,  Next: Gsl_multifit,  Prev: Gsl_integration,  Up: Top

28 Module `Gsl_fit'
*******************

28.1 Description
================

Least-Squares Fitting

28.2 Interface
==============


 - type linear_fit_coeffs = {
  c0 : float ;
  c1 : float ;
  cov00 : float ;
  cov01 : float ;
  cov11 : float ;
  sumsq : float ;
 }


 - val linear :
     ?weight:float array ->
       float array -> float array -> linear_fit_coeffs
   

 - val linear_est :
     float -> coeffs:linear_fit_coeffs -> Gsl_fun.result
   

 - type mul_fit_coeffs = {
  m_c1 : float ;
  m_cov11 : float ;
  m_sumsq : float ;
 }
   

 - val mul :
     ?weight:float array -> float array -> float array -> mul_fit_coeffs
   

 - val mul_est :
     float -> coeffs:mul_fit_coeffs -> Gsl_fun.result
   

File: gsl-ocaml.info,  Node: Gsl_multifit,  Next: Gsl_multifit_nlin,  Prev: Gsl_fit,  Up: Top

29 Module `Gsl_multifit'
************************

29.1 Description
================

Multi-parameter Least-Squares Fitting

29.2 Interface
==============


 - type ws


 - val make :
     n:int -> p:int -> ws
   

 - val _linear :
     ?weight:Gsl_vectmat.vec ->
       x:Gsl_vectmat.mat ->
       y:Gsl_vectmat.vec ->
       c:Gsl_vectmat.vec -> cov:Gsl_vectmat.mat -> ws -> float
   

 - val _linear_svd :
     ?weight:Gsl_vectmat.vec ->
       x:Gsl_vectmat.mat ->
       y:Gsl_vectmat.vec ->
       tol:float ->
       c:Gsl_vectmat.vec -> cov:Gsl_vectmat.mat -> ws -> int * float
   

 - val linear :
     ?weight:Gsl_vectmat.vec ->
       Gsl_vectmat.mat ->
       Gsl_vectmat.vec -> Gsl_vector.vector * Gsl_matrix.matrix * float
   

 - val linear_est :
     x:Gsl_vectmat.vec ->
       c:Gsl_vectmat.vec -> cov:Gsl_vectmat.mat -> Gsl_fun.result
   

 - val fit_poly :
     ?weight:float array ->
       x:float array ->
       y:float array -> int -> float array * float array array * float
   

File: gsl-ocaml.info,  Node: Gsl_multifit_nlin,  Next: Gsl_root,  Prev: Gsl_multifit,  Up: Top

30 Module `Gsl_multifit_nlin'
*****************************

30.1 Description
================

Nonlinear Least-Squares Fitting

30.2 Interface
==============


 - type t


 - type kind =
  | LMSDER
  | LMDER
   

 - val make :
     kind ->
       n:int ->
       p:int -> Gsl_fun.multi_fun_fdf -> Gsl_vector.vector -> t
   

 - val name :
     t -> string
   

 - val iterate :
     t -> unit
   

 - val position :
     t -> Gsl_vector.vector -> unit
   

 - val get_state :
     t ->
       ?x:Gsl_vector.vector ->
       ?f:Gsl_vector.vector -> ?dx:Gsl_vector.vector -> unit -> unit
   

 - val test_delta :
     t -> epsabs:float -> epsrel:float -> bool
   

 - val test_gradient :
     t -> epsabs:float -> Gsl_vector.vector -> bool
   

 - val covar :
     t -> epsrel:float -> Gsl_matrix.matrix -> unit
   

File: gsl-ocaml.info,  Node: Gsl_root,  Next: Gsl_multiroot,  Prev: Gsl_multifit_nlin,  Up: Top

31 Module `Gsl_root'
********************

31.1 Description
================

One dimensional Root-Finding

Subparts
========

* Menu:

* Bracket: Gsl_root/Bracket.       Module
* Polish: Gsl_root/Polish.         Module

31.2 Interface
==============


 - module Bracket
*Note Module Bracket: Gsl_root/Bracket.


 - module Polish
   *Note Module Polish: Gsl_root/Polish.


 - val test_interval :
     lo:float -> up:float -> epsabs:float -> epsrel:float -> bool
   

 - val test_delta :
     x1:float -> x0:float -> epsabs:float -> epsrel:float -> bool
   

 - val test_residual :
     f:float -> epsabs:float -> bool
   

File: gsl-ocaml.info,  Node: Gsl_root/Bracket,  Next: Gsl_root/Polish,  Up: Gsl_root

31.3 Module `Gsl_root.Bracket'
==============================

31.3.1 Interface
----------------


 - type kind =
  | BISECTION
  | FALSEPOS
  | BRENT


 - type t
   

 - val make :
     kind ->
       Gsl_fun.gsl_fun -> float -> float -> t
   

 - val name :
     t -> string
   

 - val iterate :
     t -> unit
   

 - val root :
     t -> float
   

 - val interval :
     t -> float * float
   

File: gsl-ocaml.info,  Node: Gsl_root/Polish,  Prev: Gsl_root/Bracket,  Up: Gsl_root

31.4 Module `Gsl_root.Polish'
=============================

31.4.1 Interface
----------------


 - type kind =
  | NEWTON
  | SECANT
  | STEFFENSON


 - type t
   

 - val make :
     kind -> Gsl_fun.gsl_fun_fdf -> float -> t
   

 - val name :
     t -> string
   

 - val iterate :
     t -> unit
   

 - val root :
     t -> float
   

File: gsl-ocaml.info,  Node: Gsl_multiroot,  Next: Gsl_min,  Prev: Gsl_root,  Up: Top

32 Module `Gsl_multiroot'
*************************

32.1 Description
================

Multidimensional Root-Finding

Subparts
========

* Menu:

* NoDeriv: Gsl_multiroot/NoDeriv.  Module
* Deriv: Gsl_multiroot/Deriv.      Module

32.2 Interface
==============


 - module NoDeriv
*Note Module NoDeriv: Gsl_multiroot/NoDeriv.


 - module Deriv
   *Note Module Deriv: Gsl_multiroot/Deriv.


File: gsl-ocaml.info,  Node: Gsl_multiroot/NoDeriv,  Next: Gsl_multiroot/Deriv,  Up: Gsl_multiroot

32.3 Module `Gsl_multiroot.NoDeriv'
===================================

32.3.1 Interface
----------------


 - type kind =
  | HYBRIDS
  | HYBRID
  | DNEWTON
  | BROYDEN


 - type t
   

 - val make :
     kind ->
       int -> Gsl_fun.multi_fun -> Gsl_vector.vector -> t
   

 - val name :
     t -> string
   

 - val iterate :
     t -> unit
   

 - val root :
     t -> Gsl_vector.vector -> unit
   

 - val get_state :
     t ->
       ?x:Gsl_vector.vector ->
       ?f:Gsl_vector.vector -> ?dx:Gsl_vector.vector -> unit -> unit
   

 - val test_delta :
     t -> epsabs:float -> epsrel:float -> bool
   

 - val test_residual :
     t -> epsabs:float -> bool
   

File: gsl-ocaml.info,  Node: Gsl_multiroot/Deriv,  Prev: Gsl_multiroot/NoDeriv,  Up: Gsl_multiroot

32.4 Module `Gsl_multiroot.Deriv'
=================================

32.4.1 Interface
----------------


 - type kind =
  | HYBRIDSJ
  | HYBRIDJ
  | NEWTON
  | GNEWTON


 - type t
   

 - val make :
     kind ->
       int -> Gsl_fun.multi_fun_fdf -> Gsl_vector.vector -> t
   

 - val name :
     t -> string
   

 - val iterate :
     t -> unit
   

 - val root :
     t -> Gsl_vector.vector -> unit
   

 - val get_state :
     t ->
       ?x:Gsl_vector.vector ->
       ?f:Gsl_vector.vector ->
       ?j:Gsl_matrix.matrix -> ?dx:Gsl_vector.vector -> unit -> unit
   

 - val test_delta :
     t -> epsabs:float -> epsrel:float -> bool
   

 - val test_residual :
     t -> epsabs:float -> bool
   

File: gsl-ocaml.info,  Node: Gsl_min,  Next: Gsl_multimin,  Prev: Gsl_multiroot,  Up: Top

33 Module `Gsl_min'
*******************

33.1 Description
================

One dimensional Minimization

33.2 Interface
==============


 - type kind =
  | GOLDENSECTION
  | BRENT


 - type t
   

 - val make :
     kind ->
       Gsl_fun.gsl_fun -> min:float -> lo:float -> up:float -> t
   

 - val name :
     t -> string
   

 - val iterate :
     t -> unit
   

 - val minimum :
     t -> float
   

 - val interval :
     t -> float * float
   

 - val test_interval :
     x_lo:float -> x_up:float -> epsabs:float -> epsrel:float -> bool
   

File: gsl-ocaml.info,  Node: Gsl_multimin,  Next: Gsl_diff,  Prev: Gsl_min,  Up: Top

34 Module `Gsl_multimin'
************************

34.1 Description
================

Multidimensional Minimization

Subparts
========

* Menu:

* Deriv: Gsl_multimin/Deriv.       Module
* NoDeriv: Gsl_multimin/NoDeriv.   Module

34.2 Interface
==============


 - module Deriv
*Note Module Deriv: Gsl_multimin/Deriv.


 - module NoDeriv
   *Note Module NoDeriv: Gsl_multimin/NoDeriv.


File: gsl-ocaml.info,  Node: Gsl_multimin/Deriv,  Next: Gsl_multimin/NoDeriv,  Up: Gsl_multimin

34.3 Module `Gsl_multimin.Deriv'
================================

34.3.1 Interface
----------------


 - type kind =
  | CONJUGATE_FR
  | CONJUGATE_PR
  | VECTOR_BFGS
  | VECTOR_BFGS2
  | STEEPEST_DESCENT


 - type t
   

 - val make :
     kind ->
       int ->
       Gsl_fun.multim_fun_fdf ->
       x:Gsl_vector.vector -> step:float -> tol:float -> t
   

 - val name :
     t -> string
   

 - val iterate :
     t -> unit
   

 - val restart :
     t -> unit
   

 - val minimum :
     ?x:Gsl_vector.vector ->
       ?dx:Gsl_vector.vector ->
       ?g:Gsl_vector.vector -> t -> float
   

 - val test_gradient :
     t -> float -> bool
   

File: gsl-ocaml.info,  Node: Gsl_multimin/NoDeriv,  Prev: Gsl_multimin/Deriv,  Up: Gsl_multimin

34.4 Module `Gsl_multimin.NoDeriv'
==================================

34.4.1 Interface
----------------


 - type kind =
  | NM_SIMPLEX


 - type t
   

 - val make :
     kind ->
       int ->
       Gsl_fun.multim_fun ->
       x:Gsl_vector.vector -> step_size:Gsl_vector.vector -> t
   

 - val name :
     t -> string
   

 - val iterate :
     t -> unit
   

 - val minimum :
     ?x:Gsl_vector.vector -> t -> float
   

 - val size :
     t -> float
   

 - val test_size :
     t -> float -> bool
   

File: gsl-ocaml.info,  Node: Gsl_diff,  Next: Gsl_cheb,  Prev: Gsl_multimin,  Up: Top

35 Module `Gsl_diff'
********************

35.1 Description
================

Numerical Differentiation

35.2 Interface
==============


 - val central :
     Gsl_fun.gsl_fun -> float -> Gsl_fun.result


 - val forward :
     Gsl_fun.gsl_fun -> float -> Gsl_fun.result
   

 - val backward :
     Gsl_fun.gsl_fun -> float -> Gsl_fun.result
   

File: gsl-ocaml.info,  Node: Gsl_cheb,  Next: Gsl_sum,  Prev: Gsl_diff,  Up: Top

36 Module `Gsl_cheb'
********************

36.1 Description
================

Chebyshev Approximations

36.2 Interface
==============


 - type t


 - val make :
     int -> t
   

 - val order :
     t -> int
   

 - val coefs :
     t -> float array
   

 - val init :
     t -> Gsl_fun.gsl_fun -> a:float -> b:float -> unit
   

 - val eval :
     t -> ?order:int -> float -> float
   

 - val eval_err :
     t -> ?order:int -> float -> Gsl_fun.result
   

 - val deriv :
     t -> t
   

 - val integ :
     t -> t
   

File: gsl-ocaml.info,  Node: Gsl_sum,  Next: Gsl_fft,  Prev: Gsl_cheb,  Up: Top

37 Module `Gsl_sum'
*******************

37.1 Description
================

Series Acceleration

Subparts
========

* Menu:

* Trunc: Gsl_sum/Trunc.            Module

37.2 Interface
==============


 - type ws


 - val make :
     int -> ws
   

 - val accel :
     float array -> ws -> Gsl_fun.result
   

 - type ws_info = {
  size : int ;
  terms_used : int ;
  sum_plain : float ;
 }
   

 - val get_info :
     ws -> ws_info
   

 - module Trunc
   *Note Module Trunc: Gsl_sum/Trunc.


File: gsl-ocaml.info,  Node: Gsl_sum/Trunc,  Up: Gsl_sum

37.3 Module `Gsl_sum.Trunc'
===========================

37.3.1 Interface
----------------


 - type ws


 - val make :
     int -> ws
   

 - val accel :
     float array -> ws -> Gsl_fun.result
   

 - type ws_info = {
  size : int ;
  terms_used : int ;
  sum_plain : float ;
 }
   

 - val get_info :
     ws -> ws_info
   

File: gsl-ocaml.info,  Node: Gsl_fft,  Next: Gsl_monte,  Prev: Gsl_sum,  Up: Top

38 Module `Gsl_fft'
*******************

38.1 Description
================

Fast Fourier Transforms

Subparts
========

* Menu:

* Real: Gsl_fft/Real.              Module
* Halfcomplex: Gsl_fft/Halfcomplex. Module
* Complex: Gsl_fft/Complex.        Module

38.2 Interface
==============


 - exception Wrong_layout


 - type layout =
  | Real
  | Halfcomplex
  | Halfcomplex_rad2
  | Complex
   

 - type fft_array = {
  layout : Gsl_fft.layout ;
  data : float array ;
 }
   

 - module Real
   *Note Module Real: Gsl_fft/Real.


 - module Halfcomplex
   *Note Module Halfcomplex: Gsl_fft/Halfcomplex.


 - module Complex
   *Note Module Complex: Gsl_fft/Complex.


 - val unpack :
     fft_array -> Gsl_complex.complex_array
   

 - val hc_mult :
     fft_array -> fft_array -> unit
   

 - val hc_mult_rad2 :
     fft_array -> fft_array -> unit
   

File: gsl-ocaml.info,  Node: Gsl_fft/Real,  Next: Gsl_fft/Halfcomplex,  Up: Gsl_fft

38.3 Module `Gsl_fft.Real'
==========================

38.3.1 Interface
----------------


 - type workspace


 - type wavetable
   

 - val make_workspace :
     int -> workspace
   

 - val make_wavetable :
     int -> wavetable
   

 - val transform :
     ?stride:int ->
       Gsl_fft.fft_array -> wavetable -> workspace -> unit
   

 - val transform_rad2 :
     ?stride:int -> Gsl_fft.fft_array -> unit
   

 - val unpack :
     ?stride:int -> Gsl_fft.fft_array -> Gsl_fft.fft_array
   

File: gsl-ocaml.info,  Node: Gsl_fft/Halfcomplex,  Next: Gsl_fft/Complex,  Prev: Gsl_fft/Real,  Up: Gsl_fft

38.4 Module `Gsl_fft.Halfcomplex'
=================================

38.4.1 Interface
----------------


 - type wavetable


 - val make_wavetable :
     int -> wavetable
   

 - val transform :
     ?stride:int ->
       Gsl_fft.fft_array ->
       wavetable -> Gsl_fft.Real.workspace -> unit
   

 - val transform_rad2 :
     ?stride:int -> Gsl_fft.fft_array -> unit
   

 - val backward :
     ?stride:int ->
       Gsl_fft.fft_array ->
       wavetable -> Gsl_fft.Real.workspace -> unit
   

 - val backward_rad2 :
     ?stride:int -> Gsl_fft.fft_array -> unit
   

 - val inverse :
     ?stride:int ->
       Gsl_fft.fft_array ->
       wavetable -> Gsl_fft.Real.workspace -> unit
   

 - val inverse_rad2 :
     ?stride:int -> Gsl_fft.fft_array -> unit
   

 - val unpack :
     ?stride:int -> Gsl_fft.fft_array -> Gsl_fft.fft_array
   

File: gsl-ocaml.info,  Node: Gsl_fft/Complex,  Prev: Gsl_fft/Halfcomplex,  Up: Gsl_fft

38.5 Module `Gsl_fft.Complex'
=============================

38.5.1 Interface
----------------


 - type workspace


 - type wavetable
   

 - type direction =
  | Forward
  | Backward
   

 - val make_workspace :
     int -> workspace
   

 - val make_wavetable :
     int -> wavetable
   

 - val forward :
     ?stride:int ->
       Gsl_complex.complex_array ->
       wavetable -> workspace -> unit
   

 - val forward_rad2 :
     ?dif:bool -> ?stride:int -> Gsl_complex.complex_array -> unit
   

 - val transform :
     ?stride:int ->
       Gsl_complex.complex_array ->
       wavetable ->
       workspace -> direction -> unit
   

 - val transform_rad2 :
     ?dif:bool ->
       ?stride:int -> Gsl_complex.complex_array -> direction -> unit
   

 - val backward :
     ?stride:int ->
       Gsl_complex.complex_array ->
       wavetable -> workspace -> unit
   

 - val backward_rad2 :
     ?dif:bool -> ?stride:int -> Gsl_complex.complex_array -> unit
   

 - val inverse :
     ?stride:int ->
       Gsl_complex.complex_array ->
       wavetable -> workspace -> unit
   

 - val inverse_rad2 :
     ?dif:bool -> ?stride:int -> Gsl_complex.complex_array -> unit
   

File: gsl-ocaml.info,  Node: Gsl_monte,  Next: Gsl_siman,  Prev: Gsl_fft,  Up: Top

39 Module `Gsl_monte'
*********************

39.1 Description
================

Monte Carlo Integration

39.2 Interface
==============

39.2.1 High-level interface
---------------------------


 - type kind =
  | PLAIN
  | MISER
  | VEGAS


 - val integrate :
     kind ->
       Gsl_fun.monte_fun ->
       lo:float array -> up:float array -> int -> Gsl_rng.t -> Gsl_fun.result
   
39.2.2 Low-level interface
--------------------------

39.2.2.1 PLAIN algorithm
........................


 - type plain_state


 - val make_plain_state :
     int -> plain_state
   

 - val init_plain :
     plain_state -> unit
   

 - val integrate_plain :
     Gsl_fun.monte_fun ->
       lo:float array ->
       up:float array -> int -> Gsl_rng.t -> plain_state -> Gsl_fun.result
   
39.2.2.2 MISER algorithm
........................


 - type miser_state


 - type miser_params = {
  estimate_frac : float ;
  min_calls : int ;
  min_calls_per_bisection : int ;
  miser_alpha : float ;
  dither : float ;
 }
   

 - val make_miser_state :
     int -> miser_state
   

 - val init_miser :
     miser_state -> unit
   

 - val integrate_miser :
     Gsl_fun.monte_fun ->
       lo:float array ->
       up:float array -> int -> Gsl_rng.t -> miser_state -> Gsl_fun.result
   

 - val get_miser_params :
     miser_state -> miser_params
   

 - val set_miser_params :
     miser_state -> miser_params -> unit
   
39.2.2.3 VEGAS algorithm
........................


 - type vegas_state


 - type vegas_info = {
  result : float ;
  sigma : float ;
  chisq : float ;
 }
   

 - type vegas_mode =
  | STRATIFIED
  | IMPORTANCE_ONLY
  | IMPORTANCE
   

 - type vegas_params = {
  vegas_alpha : float ;
     (* 1.5 *)
  iterations : int ;
     (* 5 *)
  stage : int ;
  mode : Gsl_monte.vegas_mode ;
  verbose : int ;
  ostream : Pervasives.out_channel option ;
 }
   

 - val make_vegas_state :
     int -> vegas_state
   

 - val init_vegas :
     vegas_state -> unit
   

 - val integrate_vegas :
     Gsl_fun.monte_fun ->
       lo:float array ->
       up:float array -> int -> Gsl_rng.t -> vegas_state -> Gsl_fun.result
   

 - val get_vegas_info :
     vegas_state -> vegas_info
   

 - val get_vegas_params :
     vegas_state -> vegas_params
   

 - val set_vegas_params :
     vegas_state -> vegas_params -> unit
   

File: gsl-ocaml.info,  Node: Gsl_siman,  Next: Gsl_odeiv,  Prev: Gsl_monte,  Up: Top

40 Module `Gsl_siman'
*********************

40.1 Description
================

Simulated Annealing

40.2 Interface
==============

NB: This module is not interfaced to GSL, it is implemented in OCaml.
  It is quite simple in fact, so rather than using it you may want to
copy     the code and tweak the algorithm in your own program.

 - type params = {
  iters_fixed_T : int ;
     (* The number of iterations at each temperature *)
  step_size : float ;
     (* The maximum step size in the random walk *)
  k : float ;
     (* parameter of the Boltzmann distribution *)
  t_initial : float ;
     (* initial temperature *)
  mu_t : float ;
     (* cooling factor *)
  t_min : float ;
     (* minimum temperature *)
 }
   

 - val solve :
     Gsl_rng.t ->
       'a ->
       energ_func:('a -> float) ->
       step_func:(Gsl_rng.t -> 'a -> float -> 'a) ->
       ?print_func:('a -> unit) -> params -> 'a
   

File: gsl-ocaml.info,  Node: Gsl_odeiv,  Next: Gsl_histo,  Prev: Gsl_siman,  Up: Top

41 Module `Gsl_odeiv'
*********************

41.1 Description
================

Ordinary Differential Equations

41.2 Interface
==============


 - type system


 - val make_system :
     (float -> float array -> float array -> unit) ->
       ?jac:(float -> float array -> Gsl_matrix.matrix -> float array -> unit) ->
       int -> system
   

 - type step
   

 - type step_kind =
  | RK2
  | RK4
  | RKF45
  | RKCK
  | RK8PD
  | RK2IMP
  | RK2SIMP
  | RK4IMP
  | BSIMP
  | GEAR1
  | GEAR2
   

 - val make_step :
     step_kind -> dim:int -> step
   

 - val step_reset :
     step -> unit
   

 - val step_name :
     step -> string
   

 - val step_order :
     step -> int
   

 - val step_apply :
     step ->
       t:float ->
       h:float ->
       y:float array ->
       yerr:float array ->
       ?dydt_in:float array -> ?dydt_out:float array -> system -> unit
   

 - type control
   

 - val make_control_standard_new :
     eps_abs:float ->
       eps_rel:float -> a_y:float -> a_dydt:float -> control
   

 - val make_control_y_new :
     eps_abs:float -> eps_rel:float -> control
   

 - val make_control_yp_new :
     eps_abs:float -> eps_rel:float -> control
   

 - val make_control_scaled_new :
     eps_abs:float ->
       eps_rel:float ->
       a_y:float -> a_dydt:float -> scale_abs:float array -> control
   

 - val control_name :
     control -> string
   

 - type hadjust =
  | HADJ_DEC
  | HADJ_NIL
  | HADJ_INC
   

 - val control_hadjust :
     control ->
       step ->
       y:float array ->
       yerr:float array -> dydt:float array -> h:float -> hadjust * float
   

 - type evolve
   

 - val make_evolve :
     int -> evolve
   

 - val evolve_reset :
     evolve -> unit
   

 - val evolve_apply :
     evolve ->
       control ->
       step ->
       system ->
       t:float -> t1:float -> h:float -> y:float array -> float * float
   

File: gsl-ocaml.info,  Node: Gsl_histo,  Next: Gsl_stats,  Prev: Gsl_odeiv,  Up: Top

42 Module `Gsl_histo'
*********************

42.1 Description
================

Histograms

42.2 Interface
==============


 - type t = private {
  n : int ;
     (* number of histogram bins *)
  range : float array ;
     (* ranges of the bins ; n+1 elements *)
  bin : float array ;
     (* counts for each bin ; n elements *)
 }

   The histogram type


 - val check :
     t -> bool
   
42.2.1 Allocating histograms
----------------------------


 - val make :
     int -> t


 - val copy :
     t -> t
   

 - val set_ranges :
     t -> float array -> unit
   

 - val set_ranges_uniform :
     t -> xmin:float -> xmax:float -> unit
   
42.2.2 Updating and accessing histogram elements
------------------------------------------------


 - val accumulate :
     t -> ?w:float -> float -> unit


 - val get :
     t -> int -> float
   

 - val get_range :
     t -> int -> float * float
   

 - val h_max :
     t -> float
   

 - val h_min :
     t -> float
   

 - val bins :
     t -> int
   

 - val reset :
     t -> unit
   
42.2.3 Searching histogram ranges
---------------------------------


 - val find :
     t -> float -> int

42.2.4 Histograms statistics
----------------------------


 - val max_val :
     t -> float


 - val max_bin :
     t -> int
   

 - val min_val :
     t -> float
   

 - val min_bin :
     t -> int
   

 - val mean :
     t -> float
   

 - val sigma :
     t -> float
   

 - val sum :
     t -> float
   
42.2.5 Histogram operations
---------------------------


 - val equal_bins_p :
     t -> t -> bool


 - val add :
     t -> t -> unit
   

 - val sub :
     t -> t -> unit
   

 - val mul :
     t -> t -> unit
   

 - val div :
     t -> t -> unit
   

 - val scale :
     t -> float -> unit
   

 - val shift :
     t -> float -> unit
   
42.2.6 Resampling
-----------------


 - type histo_pdf = private {
  pdf_n : int ;
  pdf_range : float array ;
  pdf_sum : float array ;
 }


 - val init :
     t -> histo_pdf
   

 - val sample :
     histo_pdf -> float -> float
   

File: gsl-ocaml.info,  Node: Gsl_stats,  Next: Gsl_wavelet,  Prev: Gsl_histo,  Up: Top

43 Module `Gsl_stats'
*********************

43.1 Description
================

Statistics

43.2 Interface
==============


 - val mean :
     ?w:float array -> float array -> float


 - val variance :
     ?w:float array -> ?mean:float -> float array -> float
   

 - val sd :
     ?w:float array -> ?mean:float -> float array -> float
   

 - val variance_with_fixed_mean :
     ?w:float array -> mean:float -> float array -> float
   

 - val sd_with_fixed_mean :
     ?w:float array -> mean:float -> float array -> float
   

 - val absdev :
     ?w:float array -> ?mean:float -> float array -> float
   

 - val skew :
     ?w:float array -> float array -> float
   

 - val skew_m_sd :
     ?w:float array -> mean:float -> sd:float -> float array -> float
   

 - val kurtosis :
     ?w:float array -> float array -> float
   

 - val kurtosis_m_sd :
     ?w:float array -> mean:float -> sd:float -> float array -> float
   

 - val lag1_autocorrelation :
     mean:float -> float array -> float
   

 - val covariance :
     float array -> float array -> float
   

 - val covariance_m :
     mean1:float -> float array -> mean2:float -> float array -> float
   

 - val max :
     float array -> float
   

 - val min :
     float array -> float
   

 - val minmax :
     float array -> float * float
   

 - val max_index :
     float array -> int
   

 - val min_index :
     float array -> int
   

 - val minmax_index :
     float array -> int * int
   

 - val quantile_from_sorted_data :
     float array -> float -> float
   

 - val correlation :
     float array -> float array -> float
   

File: gsl-ocaml.info,  Node: Gsl_wavelet,  Next: Gsl_bspline,  Prev: Gsl_stats,  Up: Top

44 Module `Gsl_wavelet'
***********************

44.1 Description
================

Wavelet Transforms

44.2 Interface
==============


 - type t


 - type ws
   

 - type kind =
  | DAUBECHIES
  | DAUBECHIES_CENTERED
  | HAAR
  | HAAR_CENTERED
  | BSPLINE
  | BSPLINE_CENTERED
   

 - type direction =
  | FORWARD
  | BACKWARD
   

 - val make :
     kind -> int -> t
   

 - val name :
     t -> string
   

 - val workspace_make :
     int -> ws
   

 - val workspace_size :
     ws -> int
   
44.2.1 1D transforms
--------------------


 - val transform_array :
     t ->
       direction ->
       ?ws:ws ->
       ?stride:int -> ?off:int -> ?len:int -> float array -> unit


 - val transform_forward :
     t ->
       ?ws:ws ->
       ?stride:int -> ?off:int -> ?len:int -> float array -> unit
   

 - val transform_inverse :
     t ->
       ?ws:ws ->
       ?stride:int -> ?off:int -> ?len:int -> float array -> unit
   

 - val transform_vector_flat :
     t ->
       direction -> ?ws:ws -> Gsl_vector_flat.vector -> unit
   

 - val transform_vector :
     t ->
       direction -> ?ws:ws -> Gsl_vector.vector -> unit
   

 - val transform_gen :
     t ->
       direction -> ?ws:ws -> [< Gsl_vectmat.vec ] -> unit
   
44.2.2 2D transforms
--------------------


 - type ordering =
  | STANDARD
  | NON_STANDARD


 - val transform_matrix_flat :
     t ->
       ordering ->
       direction -> ?ws:ws -> Gsl_matrix_flat.matrix -> unit
   

 - val transform_matrix :
     t ->
       ordering ->
       direction -> ?ws:ws -> Gsl_matrix.matrix -> unit
   

 - val transform_matrix_gen :
     t ->
       ordering ->
       direction -> ?ws:ws -> [< Gsl_vectmat.mat ] -> unit
   

File: gsl-ocaml.info,  Node: Gsl_bspline,  Next: Gsl_const,  Prev: Gsl_wavelet,  Up: Top

45 Module `Gsl_bspline'
***********************

45.1 Description
================

Basis Splines

45.2 Interface
==============


 - type ws


 - val make :
     k:int -> nbreak:int -> ws
   

 - val ncoeffs :
     ws -> int
   

 - val knots :
     [< Gsl_vectmat.vec ] -> ws -> unit
   

 - val knots_uniform :
     a:float -> b:float -> ws -> unit
   

 - val _eval :
     float -> [< Gsl_vectmat.vec ] -> ws -> unit
   

 - val eval :
     ws -> float -> [> Gsl_vectmat.vec ]
   

File: gsl-ocaml.info,  Node: Gsl_const,  Next: Gsl_sf,  Prev: Gsl_bspline,  Up: Top

46 Module `Gsl_const'
*********************

46.1 Description
================

Values of physical constants

46.2 Interface
==============


 - val cgsm_speed_of_light :
     float


 - val cgsm_gravitational_constant :
     float
   

 - val cgsm_plancks_constant_h :
     float
   

 - val cgsm_plancks_constant_hbar :
     float
   

 - val cgsm_astronomical_unit :
     float
   

 - val cgsm_light_year :
     float
   

 - val cgsm_parsec :
     float
   

 - val cgsm_grav_accel :
     float
   

 - val cgsm_electron_volt :
     float
   

 - val cgsm_mass_electron :
     float
   

 - val cgsm_mass_muon :
     float
   

 - val cgsm_mass_proton :
     float
   

 - val cgsm_mass_neutron :
     float
   

 - val cgsm_rydberg :
     float
   

 - val cgsm_boltzmann :
     float
   

 - val cgsm_molar_gas :
     float
   

 - val cgsm_standard_gas_volume :
     float
   

 - val cgsm_minute :
     float
   

 - val cgsm_hour :
     float
   

 - val cgsm_day :
     float
   

 - val cgsm_week :
     float
   

 - val cgsm_inch :
     float
   

 - val cgsm_foot :
     float
   

 - val cgsm_yard :
     float
   

 - val cgsm_mile :
     float
   

 - val cgsm_nautical_mile :
     float
   

 - val cgsm_fathom :
     float
   

 - val cgsm_mil :
     float
   

 - val cgsm_point :
     float
   

 - val cgsm_texpoint :
     float
   

 - val cgsm_micron :
     float
   

 - val cgsm_angstrom :
     float
   

 - val cgsm_hectare :
     float
   

 - val cgsm_acre :
     float
   

 - val cgsm_barn :
     float
   

 - val cgsm_liter :
     float
   

 - val cgsm_us_gallon :
     float
   

 - val cgsm_quart :
     float
   

 - val cgsm_pint :
     float
   

 - val cgsm_cup :
     float
   

 - val cgsm_fluid_ounce :
     float
   

 - val cgsm_tablespoon :
     float
   

 - val cgsm_teaspoon :
     float
   

 - val cgsm_canadian_gallon :
     float
   

 - val cgsm_uk_gallon :
     float
   

 - val cgsm_miles_per_hour :
     float
   

 - val cgsm_kilometers_per_hour :
     float
   

 - val cgsm_knot :
     float
   

 - val cgsm_pound_mass :
     float
   

 - val cgsm_ounce_mass :
     float
   

 - val cgsm_ton :
     float
   

 - val cgsm_metric_ton :
     float
   

 - val cgsm_uk_ton :
     float
   

 - val cgsm_troy_ounce :
     float
   

 - val cgsm_carat :
     float
   

 - val cgsm_unified_atomic_mass :
     float
   

 - val cgsm_gram_force :
     float
   

 - val cgsm_pound_force :
     float
   

 - val cgsm_kilopound_force :
     float
   

 - val cgsm_poundal :
     float
   

 - val cgsm_calorie :
     float
   

 - val cgsm_btu :
     float
   

 - val cgsm_therm :
     float
   

 - val cgsm_horsepower :
     float
   

 - val cgsm_bar :
     float
   

 - val cgsm_std_atmosphere :
     float
   

 - val cgsm_torr :
     float
   

 - val cgsm_meter_of_mercury :
     float
   

 - val cgsm_inch_of_mercury :
     float
   

 - val cgsm_inch_of_water :
     float
   

 - val cgsm_psi :
     float
   

 - val cgsm_poise :
     float
   

 - val cgsm_stokes :
     float
   

 - val cgsm_stilb :
     float
   

 - val cgsm_lumen :
     float
   

 - val cgsm_lux :
     float
   

 - val cgsm_phot :
     float
   

 - val cgsm_footcandle :
     float
   

 - val cgsm_lambert :
     float
   

 - val cgsm_footlambert :
     float
   

 - val cgsm_curie :
     float
   

 - val cgsm_roentgen :
     float
   

 - val cgsm_rad :
     float
   

 - val cgsm_solar_mass :
     float
   

 - val cgsm_bohr_radius :
     float
   

 - val cgsm_newton :
     float
   

 - val cgsm_dyne :
     float
   

 - val cgsm_joule :
     float
   

 - val cgsm_erg :
     float
   

 - val cgsm_stefan_boltzmann_constant :
     float
   

 - val cgsm_thomson_cross_section :
     float
   

 - val cgsm_bohr_magneton :
     float
   

 - val cgsm_nuclear_magneton :
     float
   

 - val cgsm_electron_magnetic_moment :
     float
   

 - val cgsm_proton_magnetic_moment :
     float
   

 - val cgsm_faraday :
     float
   

 - val cgsm_electron_charge :
     float
   

 - val mksa_speed_of_light :
     float
   

 - val mksa_gravitational_constant :
     float
   

 - val mksa_plancks_constant_h :
     float
   

 - val mksa_plancks_constant_hbar :
     float
   

 - val mksa_astronomical_unit :
     float
   

 - val mksa_light_year :
     float
   

 - val mksa_parsec :
     float
   

 - val mksa_grav_accel :
     float
   

 - val mksa_electron_volt :
     float
   

 - val mksa_mass_electron :
     float
   

 - val mksa_mass_muon :
     float
   

 - val mksa_mass_proton :
     float
   

 - val mksa_mass_neutron :
     float
   

 - val mksa_rydberg :
     float
   

 - val mksa_boltzmann :
     float
   

 - val mksa_molar_gas :
     float
   

 - val mksa_standard_gas_volume :
     float
   

 - val mksa_minute :
     float
   

 - val mksa_hour :
     float
   

 - val mksa_day :
     float
   

 - val mksa_week :
     float
   

 - val mksa_inch :
     float
   

 - val mksa_foot :
     float
   

 - val mksa_yard :
     float
   

 - val mksa_mile :
     float
   

 - val mksa_nautical_mile :
     float
   

 - val mksa_fathom :
     float
   

 - val mksa_mil :
     float
   

 - val mksa_point :
     float
   

 - val mksa_texpoint :
     float
   

 - val mksa_micron :
     float
   

 - val mksa_angstrom :
     float
   

 - val mksa_hectare :
     float
   

 - val mksa_acre :
     float
   

 - val mksa_barn :
     float
   

 - val mksa_liter :
     float
   

 - val mksa_us_gallon :
     float
   

 - val mksa_quart :
     float
   

 - val mksa_pint :
     float
   

 - val mksa_cup :
     float
   

 - val mksa_fluid_ounce :
     float
   

 - val mksa_tablespoon :
     float
   

 - val mksa_teaspoon :
     float
   

 - val mksa_canadian_gallon :
     float
   

 - val mksa_uk_gallon :
     float
   

 - val mksa_miles_per_hour :
     float
   

 - val mksa_kilometers_per_hour :
     float
   

 - val mksa_knot :
     float
   

 - val mksa_pound_mass :
     float
   

 - val mksa_ounce_mass :
     float
   

 - val mksa_ton :
     float
   

 - val mksa_metric_ton :
     float
   

 - val mksa_uk_ton :
     float
   

 - val mksa_troy_ounce :
     float
   

 - val mksa_carat :
     float
   

 - val mksa_unified_atomic_mass :
     float
   

 - val mksa_gram_force :
     float
   

 - val mksa_pound_force :
     float
   

 - val mksa_kilopound_force :
     float
   

 - val mksa_poundal :
     float
   

 - val mksa_calorie :
     float
   

 - val mksa_btu :
     float
   

 - val mksa_therm :
     float
   

 - val mksa_horsepower :
     float
   

 - val mksa_bar :
     float
   

 - val mksa_std_atmosphere :
     float
   

 - val mksa_torr :
     float
   

 - val mksa_meter_of_mercury :
     float
   

 - val mksa_inch_of_mercury :
     float
   

 - val mksa_inch_of_water :
     float
   

 - val mksa_psi :
     float
   

 - val mksa_poise :
     float
   

 - val mksa_stokes :
     float
   

 - val mksa_stilb :
     float
   

 - val mksa_lumen :
     float
   

 - val mksa_lux :
     float
   

 - val mksa_phot :
     float
   

 - val mksa_footcandle :
     float
   

 - val mksa_lambert :
     float
   

 - val mksa_footlambert :
     float
   

 - val mksa_curie :
     float
   

 - val mksa_roentgen :
     float
   

 - val mksa_rad :
     float
   

 - val mksa_solar_mass :
     float
   

 - val mksa_bohr_radius :
     float
   

 - val mksa_newton :
     float
   

 - val mksa_dyne :
     float
   

 - val mksa_joule :
     float
   

 - val mksa_erg :
     float
   

 - val mksa_stefan_boltzmann_constant :
     float
   

 - val mksa_thomson_cross_section :
     float
   

 - val mksa_bohr_magneton :
     float
   

 - val mksa_nuclear_magneton :
     float
   

 - val mksa_electron_magnetic_moment :
     float
   

 - val mksa_proton_magnetic_moment :
     float
   

 - val mksa_faraday :
     float
   

 - val mksa_electron_charge :
     float
   

 - val mksa_vacuum_permittivity :
     float
   

 - val mksa_vacuum_permeability :
     float
   

 - val mksa_debye :
     float
   

 - val mksa_gauss :
     float
   

 - val num_fine_structure :
     float
   

 - val num_avogadro :
     float
   

 - val num_yotta :
     float
   

 - val num_zetta :
     float
   

 - val num_exa :
     float
   

 - val num_peta :
     float
   

 - val num_tera :
     float
   

 - val num_giga :
     float
   

 - val num_mega :
     float
   

 - val num_kilo :
     float
   

 - val num_milli :
     float
   

 - val num_micro :
     float
   

 - val num_nano :
     float
   

 - val num_pico :
     float
   

 - val num_femto :
     float
   

 - val num_atto :
     float
   

 - val num_zepto :
     float
   

 - val num_yocto :
     float
   

File: gsl-ocaml.info,  Node: Gsl_sf,  Next: Gsl_cdf,  Prev: Gsl_const,  Up: Top

47 Module `Gsl_sf'
******************

47.1 Description
================

Special functions

47.2 Interface
==============


 - val airy_Ai :
     float -> Gsl_fun.mode -> float


 - val airy_Ai_e :
     float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val airy_Bi :
     float -> Gsl_fun.mode -> float
   

 - val airy_Bi_e :
     float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val airy_Ai_scaled :
     float -> Gsl_fun.mode -> float
   

 - val airy_Ai_scaled_e :
     float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val airy_Bi_scaled :
     float -> Gsl_fun.mode -> float
   

 - val airy_Bi_scaled_e :
     float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val airy_Ai_deriv :
     float -> Gsl_fun.mode -> float
   

 - val airy_Ai_deriv_e :
     float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val airy_Bi_deriv :
     float -> Gsl_fun.mode -> float
   

 - val airy_Bi_deriv_e :
     float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val airy_Ai_deriv_scaled :
     float -> Gsl_fun.mode -> float
   

 - val airy_Ai_deriv_scaled_e :
     float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val airy_Bi_deriv_scaled :
     float -> Gsl_fun.mode -> float
   

 - val airy_Bi_deriv_scaled_e :
     float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val airy_zero_Ai :
     int -> float
   

 - val airy_zero_Ai_e :
     int -> Gsl_fun.result
   

 - val airy_zero_Bi :
     int -> float
   

 - val airy_zero_Bi_e :
     int -> Gsl_fun.result
   

 - val bessel_J0 :
     float -> float
   

 - val bessel_J0_e :
     float -> Gsl_fun.result
   

 - val bessel_J1 :
     float -> float
   

 - val bessel_J1_e :
     float -> Gsl_fun.result
   

 - val bessel_Jn :
     int -> float -> float
   

 - val bessel_Jn_e :
     int -> float -> Gsl_fun.result
   

 - val bessel_Jn_array :
     int -> float -> float array -> unit
   

 - val bessel_Y0 :
     float -> float
   

 - val bessel_Y0_e :
     float -> Gsl_fun.result
   

 - val bessel_Y1 :
     float -> float
   

 - val bessel_Y1_e :
     float -> Gsl_fun.result
   

 - val bessel_Yn :
     int -> float -> float
   

 - val bessel_Yn_e :
     int -> float -> Gsl_fun.result
   

 - val bessel_Yn_array :
     int -> float -> float array -> unit
   

 - val bessel_I0 :
     float -> float
   

 - val bessel_I0_e :
     float -> Gsl_fun.result
   

 - val bessel_I1 :
     float -> float
   

 - val bessel_I1_e :
     float -> Gsl_fun.result
   

 - val bessel_In :
     int -> float -> float
   

 - val bessel_In_e :
     int -> float -> Gsl_fun.result
   

 - val bessel_In_array :
     int -> float -> float array -> unit
   

 - val bessel_K0 :
     float -> float
   

 - val bessel_K0_e :
     float -> Gsl_fun.result
   

 - val bessel_K1 :
     float -> float
   

 - val bessel_K1_e :
     float -> Gsl_fun.result
   

 - val bessel_Kn :
     int -> float -> float
   

 - val bessel_Kn_e :
     int -> float -> Gsl_fun.result
   

 - val bessel_Kn_array :
     int -> float -> float array -> unit
   

 - val bessel_I0_scaled :
     float -> float
   

 - val bessel_I0_scaled_e :
     float -> Gsl_fun.result
   

 - val bessel_I1_scaled :
     float -> float
   

 - val bessel_I1_scaled_e :
     float -> Gsl_fun.result
   

 - val bessel_In :
     int -> float -> float
   

 - val bessel_In_e :
     int -> float -> Gsl_fun.result
   

 - val bessel_In_scaled_array :
     int -> float -> float array -> unit
   

 - val bessel_K0_scaled :
     float -> float
   

 - val bessel_K0_scaled_e :
     float -> Gsl_fun.result
   

 - val bessel_K1_scaled :
     float -> float
   

 - val bessel_K1_scaled_e :
     float -> Gsl_fun.result
   

 - val bessel_Kn :
     int -> float -> float
   

 - val bessel_Kn_e :
     int -> float -> Gsl_fun.result
   

 - val bessel_Kn_scaled_array :
     int -> float -> float array -> unit
   

 - val bessel_j0 :
     float -> float
   

 - val bessel_j0_e :
     float -> Gsl_fun.result
   

 - val bessel_j1 :
     float -> float
   

 - val bessel_j1_e :
     float -> Gsl_fun.result
   

 - val bessel_j2 :
     float -> float
   

 - val bessel_j2_e :
     float -> Gsl_fun.result
   

 - val bessel_jl :
     int -> float -> float
   

 - val bessel_jl_e :
     int -> float -> Gsl_fun.result
   

 - val bessel_jl_array :
     int -> float -> float array -> unit
   

 - val bessel_jl_steed_array :
     float -> float array -> unit
   

 - val bessel_y0 :
     float -> float
   

 - val bessel_y0_e :
     float -> Gsl_fun.result
   

 - val bessel_y1 :
     float -> float
   

 - val bessel_y1_e :
     float -> Gsl_fun.result
   

 - val bessel_y2 :
     float -> float
   

 - val bessel_y2_e :
     float -> Gsl_fun.result
   

 - val bessel_yl :
     int -> float -> float
   

 - val bessel_yl_e :
     int -> float -> Gsl_fun.result
   

 - val bessel_yl_array :
     int -> float -> float array -> unit
   

 - val bessel_i0_scaled :
     float -> float
   

 - val bessel_i0_scaled_e :
     float -> Gsl_fun.result
   

 - val bessel_i1_scaled :
     float -> float
   

 - val bessel_i1_scaled_e :
     float -> Gsl_fun.result
   

 - val bessel_il_scaled :
     int -> float -> float
   

 - val bessel_il_scaled_e :
     int -> float -> Gsl_fun.result
   

 - val bessel_il_scaled_array :
     int -> float -> float array -> unit
   

 - val bessel_k0_scaled :
     float -> float
   

 - val bessel_k0_scaled_e :
     float -> Gsl_fun.result
   

 - val bessel_k1_scaled :
     float -> float
   

 - val bessel_k1_scaled_e :
     float -> Gsl_fun.result
   

 - val bessel_kl_scaled :
     int -> float -> float
   

 - val bessel_kl_scaled_e :
     int -> float -> Gsl_fun.result
   

 - val bessel_kl_scaled_array :
     int -> float -> float array -> unit
   

 - val bessel_Jnu :
     float -> float -> float
   

 - val bessel_Jnu_e :
     float -> float -> Gsl_fun.result
   

 - val bessel_sequence_Jnu_e :
     float -> Gsl_fun.mode -> float array -> unit
   

 - val bessel_Ynu :
     float -> float -> float
   

 - val bessel_Ynu_e :
     float -> float -> Gsl_fun.result
   

 - val bessel_Inu :
     float -> float -> float
   

 - val bessel_Inu_e :
     float -> float -> Gsl_fun.result
   

 - val bessel_Inu_scaled :
     float -> float -> float
   

 - val bessel_Inu_scaled_e :
     float -> float -> Gsl_fun.result
   

 - val bessel_Knu :
     float -> float -> float
   

 - val bessel_Knu_e :
     float -> float -> Gsl_fun.result
   

 - val bessel_lnKnu :
     float -> float -> float
   

 - val bessel_lnKnu_e :
     float -> float -> Gsl_fun.result
   

 - val bessel_Knu_scaled :
     float -> float -> float
   

 - val bessel_Knu_scaled_e :
     float -> float -> Gsl_fun.result
   

 - val bessel_zero_J0 :
     int -> float
   

 - val bessel_zero_J0_e :
     int -> Gsl_fun.result
   

 - val bessel_zero_J1 :
     int -> float
   

 - val bessel_zero_J1_e :
     int -> Gsl_fun.result
   

 - val bessel_zero_Jnu :
     float -> int -> float
   

 - val bessel_zero_Jnu_e :
     float -> int -> Gsl_fun.result
   

 - val clausen :
     float -> float
   

 - val clausen_e :
     float -> Gsl_fun.result
   

 - val hydrogenicR_1 :
     float -> float -> float
   

 - val hydrogenicR_1_e :
     float -> float -> Gsl_fun.result
   

 - val hydrogenicR :
     int -> int -> float -> float -> float
   

 - val hydrogenicR_e :
     int -> int -> float -> float -> Gsl_fun.result
   

 - val coulomb_CL_e :
     float -> float -> Gsl_fun.result
   

 - val coulomb_CL_array :
     float -> float -> float array -> unit
   

 - val dawson :
     float -> float
   

 - val dawson_e :
     float -> Gsl_fun.result
   

 - val debye_1 :
     float -> float
   

 - val debye_1_e :
     float -> Gsl_fun.result
   

 - val debye_2 :
     float -> float
   

 - val debye_2_e :
     float -> Gsl_fun.result
   

 - val debye_3 :
     float -> float
   

 - val debye_3_e :
     float -> Gsl_fun.result
   

 - val debye_4 :
     float -> float
   

 - val debye_4_e :
     float -> Gsl_fun.result
   

 - val debye_5 :
     float -> float
   

 - val debye_5_e :
     float -> Gsl_fun.result
   

 - val debye_6 :
     float -> float
   

 - val debye_6_e :
     float -> Gsl_fun.result
   

 - val dilog :
     float -> float
   

 - val dilog_e :
     float -> Gsl_fun.result
   

 - val complex_dilog_xy_e :
     float -> float -> Gsl_fun.result * Gsl_fun.result
   

 - val complex_dilog_e :
     float -> float -> Gsl_fun.result * Gsl_fun.result
   

 - val complex_spence_xy_e :
     float -> float -> Gsl_fun.result * Gsl_fun.result
   

 - val multiply_e :
     float -> float -> Gsl_fun.result
   

 - val multiply_err_e :
     x:float -> dx:float -> y:float -> dy:float -> Gsl_fun.result
   

 - val ellint_Kcomp :
     float -> Gsl_fun.mode -> float
   

 - val ellint_Kcomp_e :
     float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val ellint_Ecomp :
     float -> Gsl_fun.mode -> float
   

 - val ellint_Ecomp_e :
     float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val ellint_Pcomp :
     float -> float -> Gsl_fun.mode -> float
   

 - val ellint_Pcomp_e :
     float -> float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val ellint_Dcomp :
     float -> Gsl_fun.mode -> float
   

 - val ellint_Dcomp_e :
     float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val ellint_F :
     float -> float -> Gsl_fun.mode -> float
   

 - val ellint_F_e :
     float -> float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val ellint_E :
     float -> float -> Gsl_fun.mode -> float
   

 - val ellint_E_e :
     float -> float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val ellint_P :
     float -> float -> float -> Gsl_fun.mode -> float
   

 - val ellint_P_e :
     float -> float -> float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val ellint_D :
     float -> float -> float -> Gsl_fun.mode -> float
   

 - val ellint_D_e :
     float -> float -> float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val ellint_RC :
     float -> float -> Gsl_fun.mode -> float
   

 - val ellint_RC_e :
     float -> float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val ellint_RD :
     float -> float -> float -> Gsl_fun.mode -> float
   

 - val ellint_RD_e :
     float -> float -> float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val ellint_RF :
     float -> float -> float -> Gsl_fun.mode -> float
   

 - val ellint_RF_e :
     float -> float -> float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val ellint_RJ :
     float -> float -> float -> float -> Gsl_fun.mode -> float
   

 - val ellint_RJ_e :
     float -> float -> float -> float -> Gsl_fun.mode -> Gsl_fun.result
   

 - val erf :
     float -> float
   

 - val erf_e :
     float -> Gsl_fun.result
   

 - val erfc :
     float -> float
   

 - val erfc_e :
     float -> Gsl_fun.result
   

 - val log_erfc :
     float -> float
   

 - val log_erfc_e :
     float -> Gsl_fun.result
   

 - val erf_Z :
     float -> float
   

 - val erf_Z_e :
     float -> Gsl_fun.result
   

 - val erf_Q :
     float -> float
   

 - val erf_Q_e :
     float -> Gsl_fun.result
   

 - val exp :
     float -> float
   

 - val exp_e :
     float -> Gsl_fun.result
   

 - val exp_e10 :
     float -> Gsl_fun.result_e10
   

 - val exp_mult :
     float -> float -> float
   

 - val exp_mult_e :
     float -> float -> Gsl_fun.result
   

 - val exp_mult_e10 :
     float -> float -> Gsl_fun.result_e10
   

 - val expm1 :
     float -> float
   

 - val expm1_e :
     float -> Gsl_fun.result
   

 - val exprel :
     float -> float
   

 - val exprel_e :
     float -> Gsl_fun.result
   

 - val exprel_2 :
     float -> float
   

 - val exprel_2_e :
     float -> Gsl_fun.result
   

 - val exprel_n :
     int -> float -> float
   

 - val exprel_n_e :
     int -> float -> Gsl_fun.result
   

 - val exp_err_e :
     x:float -> dx:float -> Gsl_fun.result
   

 - val exp_err_e10 :
     x:float -> dx:float -> Gsl_fun.result_e10
   

 - val exp_mult_err_e :
     x:float -> dx:float -> y:float -> dy:float -> Gsl_fun.result
   

 - val exp_mult_err_e10_e :
     x:float -> dx:float -> y:float -> dy:float -> Gsl_fun.result_e10
   

 - val expint_E1 :
     float -> float
   

 - val expint_E1_e :
     float -> Gsl_fun.result
   

 - val expint_E2 :
     float -> float
   

 - val expint_E2_e :
     float -> Gsl_fun.result
   

 - val expint_E1_scaled :
     float -> float
   

 - val expint_E1_scaled_e :
     float -> Gsl_fun.result
   

 - val expint_E2_scaled :
     float -> float
   

 - val expint_E2_scaled_e :
     float -> Gsl_fun.result
   

 - val expint_Ei :
     float -> float
   

 - val expint_Ei_e :
     float -> Gsl_fun.result
   

 - val expint_Ei_scaled :
     float -> float
   

 - val expint_Ei_scaled_e :
     float -> Gsl_fun.result
   

 - val shi :
     float -> float
   

 - val chi :
     float -> float
   

 - val expint_3 :
     float -> float
   

 - val expint_3_e :
     float -> Gsl_fun.result
   

 - val si :
     float -> float
   

 - val ci :
     float -> float
   

 - val atanint :
     float -> float
   

 - val atanint_e :
     float -> Gsl_fun.result
   

 - val fermi_dirac_m1 :
     float -> float
   

 - val fermi_dirac_m1_e :
     float -> Gsl_fun.result
   

 - val fermi_dirac_0 :
     float -> float
   

 - val fermi_dirac_0_e :
     float -> Gsl_fun.result
   

 - val fermi_dirac_1 :
     float -> float
   

 - val fermi_dirac_1_e :
     float -> Gsl_fun.result
   

 - val fermi_dirac_2 :
     float -> float
   

 - val fermi_dirac_2_e :
     float -> Gsl_fun.result
   

 - val fermi_dirac_int :
     int -> float -> float
   

 - val fermi_dirac_int_e :
     int -> float -> Gsl_fun.result
   

 - val fermi_dirac_mhalf :
     float -> float
   

 - val fermi_dirac_mhalf_e :
     float -> Gsl_fun.result
   

 - val fermi_dirac_half :
     float -> float
   

 - val fermi_dirac_half_e :
     float -> Gsl_fun.result
   

 - val fermi_dirac_3half :
     float -> float
   

 - val fermi_dirac_3half_e :
     float -> Gsl_fun.result
   

 - val fermi_dirac_inc_0 :
     float -> float -> float
   

 - val fermi_dirac_inc_0_e :
     float -> float -> Gsl_fun.result
   

 - val gamma :
     float -> float
   

 - val gamma_e :
     float -> Gsl_fun.result
   

 - val lngamma :
     float -> float
   

 - val lngamma_e :
     float -> Gsl_fun.result
   

 - val lngamma_sgn_e :
     float -> Gsl_fun.result * float
   

 - val gammastar :
     float -> float
   

 - val gammastar_e :
     float -> Gsl_fun.result
   

 - val gammainv :
     float -> float
   

 - val gammainv_e :
     float -> Gsl_fun.result
   

 - val lngamma_complex_e :
     float -> float -> Gsl_fun.result * Gsl_fun.result
   

 - val taylorcoeff :
     int -> float -> float
   

 - val taylorcoeff_e :
     int -> float -> Gsl_fun.result
   

 - val fact :
     int -> float
   

 - val fact_e :
     int -> Gsl_fun.result
   

 - val doublefact :
     int -> float
   

 - val doublefact_e :
     int -> Gsl_fun.result
   

 - val lnfact :
     int -> float
   

 - val lnfact_e :
     int -> Gsl_fun.result
   

 - val lndoublefact :
     int -> float
   

 - val lndoublefact_e :
     int -> Gsl_fun.result
   

 - val choose :
     int -> int -> float
   

 - val choose_e :
     int -> int -> Gsl_fun.result
   

 - val lnchoose :
     int -> int -> float
   

 - val lnchoose_e :
     int -> int -> Gsl_fun.result
   

 - val poch :
     float -> float -> float
   

 - val poch_e :
     float -> float -> Gsl_fun.result
   

 - val lnpoch :
     float -> float -> float
   

 - val lnpoch_e :
     float -> float -> Gsl_fun.result
   

 - val lnpoch_sgn_e :
     float -> float -> Gsl_fun.result * float
   

 - val pochrel :
     float -> float -> float
   

 - val pochrel_e :
     float -> float -> Gsl_fun.result
   

 - val gamma_inc_Q :
     float -> float -> float
   

 - val gamma_inc_Q_e :
     float -> float -> Gsl_fun.result
   

 - val gamma_inc_P :
     float -> float -> float
   

 - val gamma_inc_P_e :
     float -> float -> Gsl_fun.result
   

 - val gamma_inc :
     float -> float -> float
   

 - val gamma_inc_e :
     float -> float -> Gsl_fun.result
   

 - val beta :
     float -> float -> float
   

 - val beta_e :
     float -> float -> Gsl_fun.result
   

 - val lnbeta :
     float -> float -> float
   

 - val lnbeta_e :
     float -> float -> Gsl_fun.result
   

 - val lnbeta_sgn_e :
     float -> float -> Gsl_fun.result * float
   

 - val beta_inc :
     float -> float -> float -> float
   

 - val beta_inc_e :
     float -> float -> float -> Gsl_fun.result
   

 - val gegenpoly_1 :
     float -> float -> float
   

 - val gegenpoly_1_e :
     float -> float -> Gsl_fun.result
   

 - val gegenpoly_2 :
     float -> float -> float
   

 - val gegenpoly_2_e :
     float -> float -> Gsl_fun.result
   

 - val gegenpoly_3 :
     float -> float -> float
   

 - val gegenpoly_3_e :
     float -> float -> Gsl_fun.result
   

 - val gegenpoly_n :
     int -> float -> float -> float
   

 - val gegenpoly_n_e :
     int -> float -> float -> Gsl_fun.result
   

 - val gegenpoly_array :
     float -> float -> float array -> unit
   

 - val laguerre_1 :
     float -> float -> float
   

 - val laguerre_1_e :
     float -> float -> Gsl_fun.result
   

 - val laguerre_2 :
     float -> float -> float
   

 - val laguerre_2_e :
     float -> float -> Gsl_fun.result
   

 - val laguerre_3 :
     float -> float -> float
   

 - val laguerre_3_e :
     float -> float -> Gsl_fun.result
   

 - val laguerre_n :
     int -> float -> float -> float
   

 - val laguerre_n_e :
     int -> float -> float -> Gsl_fun.result
   

 - val lambert_W0 :
     float -> float
   

 - val lambert_W0_e :
     float -> Gsl_fun.result
   

 - val lambert_Wm1 :
     float -> float
   

 - val lambert_Wm1_e :
     float -> Gsl_fun.result
   

 - val legendre_P1 :
     float -> float
   

 - val legendre_P1_e :
     float -> Gsl_fun.result
   

 - val legendre_P2 :
     float -> float
   

 - val legendre_P2_e :
     float -> Gsl_fun.result
   

 - val legendre_P3 :
     float -> float
   

 - val legendre_P3_e :
     float -> Gsl_fun.result
   

 - val legendre_Pl :
     int -> float -> float
   

 - val legendre_Pl_e :
     int -> float -> Gsl_fun.result
   

 - val legendre_Pl_array :
     float -> float array -> unit
   

 - val legendre_Q0 :
     float -> float
   

 - val legendre_Q0_e :
     float -> Gsl_fun.result
   

 - val legendre_Q1 :
     float -> float
   

 - val legendre_Q1_e :
     float -> Gsl_fun.result
   

 - val legendre_Ql :
     int -> float -> float
   

 - val legendre_Ql_e :
     int -> float -> Gsl_fun.result
   

 - val legendre_Plm :
     int -> int -> float -> float
   

 - val legendre_Plm_e :
     int -> int -> float -> Gsl_fun.result
   

 - val legendre_Plm_array :
     int -> int -> float -> float array -> unit
   

 - val legendre_sphPlm :
     int -> int -> float -> float
   

 - val legendre_sphPlm_e :
     int -> int -> float -> Gsl_fun.result
   

 - val legendre_sphPlm_array :
     int -> int -> float -> float array -> unit
   

 - val legendre_array_size :
     int -> int -> int
   

 - val log :
     float -> float
   

 - val log_e :
     float -> Gsl_fun.result
   

 - val log_abs :
     float -> float
   

 - val log_abs_e :
     float -> Gsl_fun.result
   

 - val log_complex_e :
     float -> float -> Gsl_fun.result * Gsl_fun.result
   

 - val log_1plusx :
     float -> float
   

 - val log_1plusx_e :
     float -> Gsl_fun.result
   

 - val log_1plusx_mx :
     float -> float
   

 - val log_1plusx_mx_e :
     float -> Gsl_fun.result
   

 - val pow_int :
     float -> int -> float
   

 - val pow_int_e :
     float -> int -> Gsl_fun.result
   

 - val psi_int :
     int -> float
   

 - val psi_int_e :
     int -> Gsl_fun.result
   

 - val psi :
     float -> float
   

 - val psi_e :
     float -> Gsl_fun.result
   

 - val psi_1piy :
     float -> float
   

 - val psi_1piy_e :
     float -> Gsl_fun.result
   

 - val psi_complex_e :
     float -> float -> Gsl_fun.result * Gsl_fun.result
   

 - val psi_1_int :
     int -> float
   

 - val psi_1_int_e :
     int -> Gsl_fun.result
   

 - val psi_1 :
     float -> float
   

 - val psi_1_e :
     float -> Gsl_fun.result
   

 - val psi_n :
     int -> float -> float
   

 - val psi_n_e :
     int -> float -> Gsl_fun.result
   

 - val synchrotron_1 :
     float -> float
   

 - val synchrotron_1_e :
     float -> Gsl_fun.result
   

 - val synchrotron_2 :
     float -> float
   

 - val synchrotron_2_e :
     float -> Gsl_fun.result
   

 - val transport_2 :
     float -> float
   

 - val transport_2_e :
     float -> Gsl_fun.result
   

 - val transport_3 :
     float -> float
   

 - val transport_3_e :
     float -> Gsl_fun.result
   

 - val transport_4 :
     float -> float
   

 - val transport_4_e :
     float -> Gsl_fun.result
   

 - val transport_5 :
     float -> float
   

 - val transport_5_e :
     float -> Gsl_fun.result
   

 - val sin :
     float -> float
   

 - val sin_e :
     float -> Gsl_fun.result
   

 - val cos :
     float -> float
   

 - val cos_e :
     float -> Gsl_fun.result
   

 - val hypot :
     float -> float
   

 - val hypot_e :
     float -> Gsl_fun.result
   

 - val sinc :
     float -> float
   

 - val sinc_e :
     float -> Gsl_fun.result
   

 - val complex_sin_e :
     float -> float -> Gsl_fun.result * Gsl_fun.result
   

 - val complex_cos_e :
     float -> float -> Gsl_fun.result * Gsl_fun.result
   

 - val complex_logsin_e :
     float -> float -> Gsl_fun.result * Gsl_fun.result
   

 - val lnsinh :
     float -> float
   

 - val lnsinh_e :
     float -> Gsl_fun.result
   

 - val lncosh :
     float -> float
   

 - val lncosh_e :
     float -> Gsl_fun.result
   

 - val rect_of_polar :
     r:float -> theta:float -> Gsl_fun.result * Gsl_fun.result
   

 - val polar_of_rect :
     x:float -> y:float -> Gsl_fun.result * Gsl_fun.result
   

 - val angle_restrict_symm :
     float -> float
   

 - val angle_restrict_pos :
     float -> float
   

 - val sin_err_e :
     float -> dx:float -> Gsl_fun.result
   

 - val cos_err_e :
     float -> dx:float -> Gsl_fun.result
   

 - val zeta_int :
     int -> float
   

 - val zeta_int_e :
     int -> Gsl_fun.result
   

 - val zeta :
     float -> float
   

 - val zeta_e :
     float -> Gsl_fun.result
   

 - val hzeta :
     float -> float -> float
   

 - val hzeta_e :
     float -> float -> Gsl_fun.result
   

 - val eta_int :
     int -> float
   

 - val eta_int_e :
     int -> Gsl_fun.result
   

 - val eta :
     float -> float
   

 - val eta_e :
     float -> Gsl_fun.result
   

File: gsl-ocaml.info,  Node: Gsl_cdf,  Next: Types index,  Prev: Gsl_sf,  Up: Top

48 Module `Gsl_cdf'
*******************

48.1 Description
================

Cumulative distribution functions

48.2 Interface
==============


 - val ugaussian_P :
     x:float -> float


 - val ugaussian_Q :
     x:float -> float
   

 - val ugaussian_Pinv :
     p:float -> float
   

 - val ugaussian_Qinv :
     q:float -> float
   

 - val gaussian_P :
     x:float -> sigma:float -> float
   

 - val gaussian_Q :
     x:float -> sigma:float -> float
   

 - val gaussian_Pinv :
     p:float -> sigma:float -> float
   

 - val gaussian_Qinv :
     q:float -> sigma:float -> float
   

 - val gamma_P :
     x:float -> a:float -> b:float -> float
   

 - val gamma_Q :
     x:float -> a:float -> b:float -> float
   

 - val gamma_Pinv :
     p:float -> a:float -> b:float -> float
   

 - val gamma_Qinv :
     q:float -> a:float -> b:float -> float
   

 - val cauchy_P :
     x:float -> a:float -> float
   

 - val cauchy_Q :
     x:float -> a:float -> float
   

 - val cauchy_Pinv :
     p:float -> a:float -> float
   

 - val cauchy_Qinv :
     q:float -> a:float -> float
   

 - val laplace_P :
     x:float -> a:float -> float
   

 - val laplace_Q :
     x:float -> a:float -> float
   

 - val laplace_Pinv :
     p:float -> a:float -> float
   

 - val laplace_Qinv :
     q:float -> a:float -> float
   

 - val rayleigh_P :
     x:float -> sigma:float -> float
   

 - val rayleigh_Q :
     x:float -> sigma:float -> float
   

 - val rayleigh_Pinv :
     p:float -> sigma:float -> float
   

 - val rayleigh_Qinv :
     q:float -> sigma:float -> float
   

 - val chisq_P :
     x:float -> nu:float -> float
   

 - val chisq_Q :
     x:float -> nu:float -> float
   

 - val chisq_Pinv :
     p:float -> nu:float -> float
   

 - val chisq_Qinv :
     q:float -> nu:float -> float
   

 - val exponential_P :
     x:float -> mu:float -> float
   

 - val exponential_Q :
     x:float -> mu:float -> float
   

 - val exponential_Pinv :
     p:float -> mu:float -> float
   

 - val exponential_Qinv :
     q:float -> mu:float -> float
   

 - val exppow_P :
     x:float -> a:float -> b:float -> float
   

 - val exppow_Q :
     x:float -> a:float -> b:float -> float
   

 - val tdist_P :
     x:float -> nu:float -> float
   

 - val tdist_Q :
     x:float -> nu:float -> float
   

 - val tdist_Pinv :
     p:float -> nu:float -> float
   

 - val tdist_Qinv :
     q:float -> nu:float -> float
   

 - val fdist_P :
     x:float -> nu1:float -> nu2:float -> float
   

 - val fdist_Q :
     x:float -> nu1:float -> nu2:float -> float
   

 - val fdist_Pinv :
     p:float -> nu1:float -> nu2:float -> float
   

 - val fdist_Qinv :
     q:float -> nu1:float -> nu2:float -> float
   

 - val beta_P :
     x:float -> a:float -> b:float -> float
   

 - val beta_Q :
     x:float -> a:float -> b:float -> float
   

 - val beta_Pinv :
     p:float -> a:float -> b:float -> float
   

 - val beta_Qinv :
     q:float -> a:float -> b:float -> float
   

 - val flat_P :
     x:float -> a:float -> b:float -> float
   

 - val flat_Q :
     x:float -> a:float -> b:float -> float
   

 - val flat_Pinv :
     p:float -> a:float -> b:float -> float
   

 - val flat_Qinv :
     q:float -> a:float -> b:float -> float
   

 - val lognormal_P :
     x:float -> zeta:float -> sigma:float -> float
   

 - val lognormal_Q :
     x:float -> zeta:float -> sigma:float -> float
   

 - val lognormal_Pinv :
     p:float -> zeta:float -> sigma:float -> float
   

 - val lognormal_Qinv :
     q:float -> zeta:float -> sigma:float -> float
   

 - val gumbel1_P :
     x:float -> a:float -> b:float -> float
   

 - val gumbel1_Q :
     x:float -> a:float -> b:float -> float
   

 - val gumbel1_Pinv :
     p:float -> a:float -> b:float -> float
   

 - val gumbel1_Qinv :
     q:float -> a:float -> b:float -> float
   

 - val gumbel2_P :
     x:float -> a:float -> b:float -> float
   

 - val gumbel2_Q :
     x:float -> a:float -> b:float -> float
   

 - val gumbel2_Pinv :
     p:float -> a:float -> b:float -> float
   

 - val gumbel2_Qinv :
     q:float -> a:float -> b:float -> float
   

 - val weibull_P :
     x:float -> a:float -> b:float -> float
   

 - val weibull_Q :
     x:float -> a:float -> b:float -> float
   

 - val weibull_Pinv :
     p:float -> a:float -> b:float -> float
   

 - val weibull_Qinv :
     q:float -> a:float -> b:float -> float
   

 - val pareto_P :
     x:float -> a:float -> b:float -> float
   

 - val pareto_Q :
     x:float -> a:float -> b:float -> float
   

 - val pareto_Pinv :
     p:float -> a:float -> b:float -> float
   

 - val pareto_Qinv :
     q:float -> a:float -> b:float -> float
   

 - val logistic_P :
     x:float -> a:float -> float
   

 - val logistic_Q :
     x:float -> a:float -> float
   

 - val logistic_Pinv :
     p:float -> a:float -> float
   

 - val logistic_Qinv :
     q:float -> a:float -> float
   

 - val binomial_P :
     k:int -> p:float -> n:int -> float
   

 - val binomial_Q :
     k:int -> p:float -> n:int -> float
   

 - val poisson_P :
     k:int -> mu:float -> float
   

 - val poisson_Q :
     k:int -> mu:float -> float
   

 - val geometric_P :
     k:int -> p:float -> float
   

 - val geometric_Q :
     k:int -> p:float -> float
   

 - val negative_binomial_P :
     k:int -> p:float -> n:float -> float
   

 - val negative_binomial_Q :
     k:int -> p:float -> n:float -> float
   

 - val pascal_P :
     k:int -> p:float -> n:int -> float
   

 - val pascal_Q :
     k:int -> p:float -> n:int -> float
   

File: gsl-ocaml.info,  Node: Types index,  Next: Exceptions index,  Prev: Gsl_cdf,  Up: Top

Types index
***********

 [index ]
* Menu:

* accel:                                 Gsl_interp.          (line  19)
* cmat:                                  Gsl_vectmat.         (line  57)
* complex:                               Gsl_complex.         (line  19)
* complex_array:                         Gsl_complex.         (line  26)
* complex_double_vector_bigarr:          Gsl_vector_complex.  (line  23)
* complex_float_mat_bigarr:              Gsl_matrix_complex/Single.
                                                              (line  11)
* complex_float_vector_bigarr:           Gsl_vector_complex/Single.
                                                              (line  11)
* complex_mat_bigarr:                    Gsl_matrix_complex.  (line  23)
* complex_mat_flat:                      Gsl_matrix_complex_flat.
                                                              (line  22)
* complex_vector_flat:                   Gsl_vector_complex_flat.
                                                              (line  21)
* control:                               Gsl_odeiv.           (line  67)
* cubic_sol:                             Gsl_poly.            (line  48)
* cvec:                                  Gsl_vectmat.         (line  54)
* diag <1>:                              Gsl_blas.            (line  43)
* diag <2>:                              Gsl_blas_flat.       (line  36)
* diag:                                  Gsl_blas_gen.        (line  36)
* direction <1>:                         Gsl_fft/Complex.     (line  19)
* direction:                             Gsl_wavelet.         (line  33)
* discrete:                              Gsl_randist.         (line 268)
* double_mat_bigarr:                     Gsl_matrix.          (line  23)
* double_mat_flat:                       Gsl_matrix_flat.     (line  22)
* double_vector_bigarr:                  Gsl_vector.          (line  26)
* double_vector_flat:                    Gsl_vector_flat.     (line  21)
* errno:                                 Gsl_error.           (line  89)
* evolve:                                Gsl_odeiv.           (line 106)
* exceptions:                            Gsl_ieee.            (line  66)
* excepts:                               Gsl_ieee.            (line  87)
* fft_array:                             Gsl_fft.             (line  38)
* float_mat_bigarr:                      Gsl_matrix/Single.   (line  11)
* float_rep:                             Gsl_ieee.            (line  32)
* float_vector_bigarr:                   Gsl_vector/Single.   (line  11)
* gsl_fun:                               Gsl_fun.             (line  57)
* gsl_fun_fdf:                           Gsl_fun.             (line  64)
* hadjust:                               Gsl_odeiv.           (line  96)
* herm_ws:                               Gsl_eigen.           (line  74)
* hermv_ws:                              Gsl_eigen.           (line  93)
* histo_pdf:                             Gsl_histo.           (line 158)
* ieee_type:                             Gsl_ieee.            (line  24)
* interp:                                Gsl_interp.          (line  81)
* interp_type:                           Gsl_interp.          (line  28)
* key:                                   Gsl_integration.     (line  38)
* kind <1>:                              Gsl_multimin/Deriv.  (line  16)
* kind <2>:                              Gsl_wavelet.         (line  28)
* kind <3>:                              Gsl_monte.           (line  22)
* kind <4>:                              Gsl_multimin/NoDeriv.
                                                              (line  12)
* kind <5>:                              Gsl_min.             (line  18)
* kind <6>:                              Gsl_multiroot/Deriv. (line  15)
* kind <7>:                              Gsl_multiroot/NoDeriv.
                                                              (line  15)
* kind <8>:                              Gsl_root/Polish.     (line  14)
* kind <9>:                              Gsl_root/Bracket.    (line  14)
* kind:                                  Gsl_multifit_nlin.   (line  21)
* layout:                                Gsl_fft.             (line  32)
* linear_fit_coeffs:                     Gsl_fit.             (line  23)
* mat:                                   Gsl_vectmat.         (line  30)
* matrix <1>:                            Gsl_matrix_complex/Single.
                                                              (line  14)
* matrix <2>:                            Gsl_matrix_complex_flat.
                                                              (line  25)
* matrix <3>:                            Gsl_matrix_complex.  (line  26)
* matrix <4>:                            Gsl_matrix_flat.     (line  25)
* matrix <5>:                            Gsl_matrix.          (line  26)
* matrix:                                Gsl_matrix/Single.   (line  14)
* miser_params:                          Gsl_monte.           (line  66)
* miser_state:                           Gsl_monte.           (line  57)
* mode:                                  Gsl_fun.             (line  45)
* monte_fun:                             Gsl_fun.             (line  67)
* mul_fit_coeffs:                        Gsl_fit.             (line  39)
* multi_fun:                             Gsl_fun.             (line  70)
* multi_fun_fdf:                         Gsl_fun.             (line  77)
* multim_fun:                            Gsl_fun.             (line  80)
* multim_fun_fdf:                        Gsl_fun.             (line  87)
* nonsymm_ws:                            Gsl_eigen.           (line 120)
* nonsymmv_ws:                           Gsl_eigen.           (line 145)
* order <1>:                             Gsl_blas_gen.        (line  20)
* order <2>:                             Gsl_blas_flat.       (line  20)
* order:                                 Gsl_blas.            (line  27)
* ordering:                              Gsl_wavelet.         (line  94)
* params:                                Gsl_siman.           (line  32)
* permut:                                Gsl_permut.          (line  16)
* plain_state:                           Gsl_monte.           (line  37)
* poly:                                  Gsl_poly.            (line  16)
* precision:                             Gsl_ieee.            (line  49)
* qawo_sine:                             Gsl_integration.     (line 133)
* qawo_table:                            Gsl_integration.     (line 128)
* qaws_table:                            Gsl_integration.     (line 103)
* qrng_type:                             Gsl_qrng.            (line  18)
* quad_sol:                              Gsl_poly.            (line  31)
* result:                                Gsl_fun.             (line  23)
* result_e10:                            Gsl_fun.             (line  33)
* rng_type:                              Gsl_rng.             (line  78)
* rounding:                              Gsl_ieee.            (line  56)
* side <1>:                              Gsl_blas_flat.       (line  41)
* side <2>:                              Gsl_blas_gen.        (line  41)
* side:                                  Gsl_blas.            (line  48)
* sort:                                  Gsl_eigen.           (line  64)
* step:                                  Gsl_odeiv.           (line  25)
* step_kind:                             Gsl_odeiv.           (line  39)
* symm_ws:                               Gsl_eigen.           (line  19)
* symmv_ws:                              Gsl_eigen.           (line  39)
* system:                                Gsl_odeiv.           (line  16)
* t <1>:                                 Gsl_min.             (line  21)
* t <2>:                                 Gsl_multimin/NoDeriv.
                                                              (line  15)
* t <3>:                                 Gsl_cheb.            (line  16)
* t <4>:                                 Gsl_wavelet.         (line  16)
* t <5>:                                 Gsl_interp.          (line  16)
* t <6>:                                 Gsl_rng.             (line  81)
* t <7>:                                 Gsl_qrng.            (line  21)
* t <8>:                                 Gsl_histo.           (line  23)
* t <9>:                                 Gsl_multifit_nlin.   (line  16)
* t <10>:                                Gsl_root/Bracket.    (line  17)
* t <11>:                                Gsl_root/Polish.     (line  17)
* t <12>:                                Gsl_multiroot/NoDeriv.
                                                              (line  18)
* t <13>:                                Gsl_multiroot/Deriv. (line  18)
* t:                                     Gsl_multimin/Deriv.  (line  19)
* transpose <1>:                         Gsl_blas.            (line  33)
* transpose <2>:                         Gsl_blas_gen.        (line  26)
* transpose:                             Gsl_blas_flat.       (line  26)
* uplo <1>:                              Gsl_blas_gen.        (line  31)
* uplo <2>:                              Gsl_blas.            (line  38)
* uplo:                                  Gsl_blas_flat.       (line  31)
* vec:                                   Gsl_vectmat.         (line  19)
* vector <1>:                            Gsl_vector.          (line  29)
* vector <2>:                            Gsl_vector_complex_flat.
                                                              (line  24)
* vector <3>:                            Gsl_vector_complex/Single.
                                                              (line  14)
* vector <4>:                            Gsl_vector_complex.  (line  26)
* vector <5>:                            Gsl_vector_flat.     (line  24)
* vector:                                Gsl_vector/Single.   (line  14)
* vegas_info:                            Gsl_monte.           (line 101)
* vegas_mode:                            Gsl_monte.           (line 107)
* vegas_params:                          Gsl_monte.           (line 119)
* vegas_state:                           Gsl_monte.           (line  94)
* wavetable <1>:                         Gsl_fft/Complex.     (line  14)
* wavetable <2>:                         Gsl_fft/Halfcomplex. (line  11)
* wavetable:                             Gsl_fft/Real.        (line  14)
* workspace <1>:                         Gsl_integration.     (line  21)
* workspace <2>:                         Gsl_fft/Complex.     (line  11)
* workspace:                             Gsl_fft/Real.        (line  11)
* ws <1>:                                Gsl_wavelet.         (line  19)
* ws <2>:                                Gsl_sum/Trunc.       (line  11)
* ws <3>:                                Gsl_multifit.        (line  16)
* ws <4>:                                Gsl_bspline.         (line  16)
* ws:                                    Gsl_sum.             (line  23)
* ws_info <1>:                           Gsl_sum/Trunc.       (line  26)
* ws_info:                               Gsl_sum.             (line  38)


File: gsl-ocaml.info,  Node: Exceptions index,  Next: Values index,  Prev: Types index,  Up: Top

Exceptions index
****************

 [index ]
* Menu:

* Gsl_exn:                               Gsl_error.            (line 92)
* Wrong_layout:                          Gsl_fft.              (line 25)

